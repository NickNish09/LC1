USED PATCH 873
-----------------
Starting pvs-allegro6.2 -qq ...
Allegro CL Enterprise Edition
6.2 [Linux (x86)] (Nov 3, 2004 23:30)
Copyright (C) 1985-2002, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.

This dynamic runtime copy of Allegro CL was built by:
   [TC8101] SRI International

;; Optimization settings: safety 1, space 1, speed 3, debug 1.
;; For a complete description of all compiler switches given the
;; current optimization settings evaluate (explain-compiler-settings).
;;---
;; Current reader case mode: :case-sensitive-lower
pvs(1): 
pvs(2): nil
pvs(9): nil
pvs(11): ; Loading /home/rwb/pvs-strategies

Defining sqrt-rew. 
Defining sqrt-rew$. 
Defining sqrt-rew-off. 
Defining sqrt-rew-off$. 
Installing rewrite rule sq_abs_neg
Installing rewrite rule sq_abs
Installing rewrite rule sq_1
Installing rewrite rule sq_0
Installing rewrite rule sq_sqrt
Installing rewrite rule sqrt_sq_neg
Installing rewrite rule sqrt_sq
Installing rewrite rule sqrt_square
Installing rewrite rule sqrt_1
Installing rewrite rule sqrt_0
Installing rewrite rule sqrt_25
Installing rewrite rule sqrt_16
Installing rewrite rule sqrt_9
Installing rewrite rule sqrt_4
Installing rewrite rule factorial_0
Installing rewrite rule factorial_1
Installing rewrite rule ln_e
Installing rewrite rule ln_1
Installing rewrite rule exp_1
Installing rewrite rule exp_0
Installing rewrite rule Riemann?_Rie
Installing rewrite rule xis_lem
Installing rewrite rule xis?
Installing rewrite rule member
Installing rewrite rule member
Installing rewrite rule finseq_appl
Installing rewrite rule not_one_element
Installing rewrite rule sort_length
Installing rewrite rule not_one_element
Installing rewrite rule set2seq_length
Installing rewrite rule set2part_length
Installing rewrite rule not_one_element
Installing rewrite rule not_one_element
Installing rewrite rule not_one_element
Installing rewrite rule not_one_element

atanh_series :  

  |-------
{1}   FORALL (n: nat, z: real_abs_lt1):
        abs(atanh(z) - atanh_series_n(z, n)) <=
         ((1 + z) ^ (2 * n + 3) + (1 - z) ^ (2 * n + 3)) /
          (2 * (2 * n + 3) * (1 - sq(z)) ^ (2 * n + 3))

Rerunning step: (skosimp*)

Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series :  

  |-------
{1}   abs(atanh(z!1) - atanh_series_n(z!1, n!1)) <=
       ((1 + z!1) ^ (2 * n!1 + 3) + (1 - z!1) ^ (2 * n!1 + 3)) /
        (2 * (2 * n!1 + 3) * (1 - sq(z!1)) ^ (2 * n!1 + 3))

Rerunning step: (lemma "atanh_taylors" ("z" "z!1" "n" "n!1"))
Applying atanh_taylors where 
  z gets z!1,
  n gets n!1,
this simplifies to: 
atanh_series :  

{-1}  EXISTS (c: between[real_abs_lt1](0, z!1)):
        atanh(z!1) =
         atanh_series_n(z!1, n!1) +
          nderiv[real_abs_lt1](2 * n!1 + 3, atanh)(c) * z!1 ^ (2 * n!1 + 3)
           / factorial(2 * n!1 + 3)
  |-------
[1]   abs(atanh(z!1) - atanh_series_n(z!1, n!1)) <=
       ((1 + z!1) ^ (2 * n!1 + 3) + (1 - z!1) ^ (2 * n!1 + 3)) /
        (2 * (2 * n!1 + 3) * (1 - sq(z!1)) ^ (2 * n!1 + 3))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series :  

{-1}  atanh(z!1) =
       atanh_series_n(z!1, n!1) +
        nderiv[real_abs_lt1](2 * n!1 + 3, atanh)(c!1) * z!1 ^ (2 * n!1 + 3)
         / factorial(2 * n!1 + 3)
  |-------
[1]   abs(atanh(z!1) - atanh_series_n(z!1, n!1)) <=
       ((1 + z!1) ^ (2 * n!1 + 3) + (1 - z!1) ^ (2 * n!1 + 3)) /
        (2 * (2 * n!1 + 3) * (1 - sq(z!1)) ^ (2 * n!1 + 3))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series :  

[-1]  atanh(z!1) =
       atanh_series_n(z!1, n!1) +
        nderiv[real_abs_lt1](2 * n!1 + 3, atanh)(c!1) * z!1 ^ (2 * n!1 + 3)
         / factorial(2 * n!1 + 3)
  |-------
{1}   abs(atanh_series_n(z!1, n!1) +
           nderiv[real_abs_lt1](2 * n!1 + 3, atanh)(c!1) *
            z!1 ^ (2 * n!1 + 3)
            / factorial(2 * n!1 + 3)
           - atanh_series_n(z!1, n!1))
       <=
       ((1 + z!1) ^ (2 * n!1 + 3) + (1 - z!1) ^ (2 * n!1 + 3)) /
        (2 * (2 * n!1 + 3) * (1 - sq(z!1)) ^ (2 * n!1 + 3))

Rerunning step: (simplify 1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series :  

[-1]  atanh(z!1) =
       atanh_series_n(z!1, n!1) +
        nderiv[real_abs_lt1](2 * n!1 + 3, atanh)(c!1) * z!1 ^ (2 * n!1 + 3)
         / factorial(2 * n!1 + 3)
  |-------
{1}   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series :  

  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (lemma "atanh_nderiv" ("n" "3+2*n!1"))
Applying atanh_nderiv where 
  n gets 3 + 2 * n!1,
this simplifies to: 
atanh_series :  

{-1}  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) =
       IF 3 + 2 * n!1 = 0 THEN atanh
       ELSIF even?(3 + 2 * n!1)
         THEN deriv[real_abs_lt1](atanhND((3 + 2 * n!1) / 2 - 1))
       ELSE atanhND((3 + 2 * n!1 - 1) / 2)
       ENDIF
  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (simplify -1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series :  

{-1}  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) =
          IF even?(3 + 2 * n!1)
         THEN deriv[real_abs_lt1](atanhND((3 + 2 * n!1) / 2 - 1))
       ELSE atanhND((2 + 2 * n!1) / 2)
  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (expand "even?" -1)
Expanding the definition of even?,
this simplifies to: 
atanh_series :  

{-1}  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) = atanhND((2 + 2 * n!1) / 2)
  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (lemma "div_cancel1" ("x" "1+n!1" "n0z" "2"))
Applying div_cancel1 where 
  x gets 1 + n!1,
  n0z gets 2,
this simplifies to: 
atanh_series :  

{-1}  2 * ((1 + n!1) / 2) = 1 + n!1
[-2]  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) = atanhND((2 + 2 * n!1) / 2)
  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
atanh_series :  

[-1]  2 * ((1 + n!1) / 2) = 1 + n!1
{-2}  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) = atanhND(1 + n!1)
  |-------
[1]   abs((nderiv[real_abs_lt1](3 + 2 * n!1, atanh)(c!1) *
            z!1 ^ (3 + 2 * n!1))
           / factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
atanh_series :  

[-1]  2 * ((1 + n!1) / 2) = 1 + n!1
[-2]  nderiv[real_abs_lt1](3 + 2 * n!1, atanh) = atanhND(1 + n!1)
  |-------
{1}   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide -1 -2)
Hiding formulas:  -1, -2,
this simplifies to: 
atanh_series :  

  |-------
[1]   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (case "1-sq(z!1)>0")
Case splitting on 
   1 - sq(z!1) > 0, 
this yields  2 subgoals: 
atanh_series.1 :  

{-1}  1 - sq(z!1) > 0
  |-------
[1]   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (case "abs(z!1^(3+2*n!1))<1")
Case splitting on 
   abs(z!1 ^ (3 + 2 * n!1)) < 1, 
this yields  2 subgoals: 
atanh_series.1.1 :  

{-1}  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-2]  1 - sq(z!1) > 0
  |-------
[1]   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (rewrite "abs_div" 1)
Found matching substitution:
n0y: nonzero_real gets factorial(3 + 2 * n!1),
x: real gets atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1),
Rewriting using abs_div, matching in 1,
this simplifies to: 
atanh_series.1.1 :  

[-1]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   abs(atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
       abs(factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (rewrite "abs_mult" 1)
Found matching substitution:
y: real gets z!1 ^ (3 + 2 * n!1),
x gets atanhND(1 + n!1)(c!1),
Rewriting using abs_mult, matching in 1,
this simplifies to: 
atanh_series.1.1 :  

[-1]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       abs(factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (expand "abs" 1 3)
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.1 :  

[-1]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (lemma "expt_pos" ("px" "1-sq(z!1)" "i" "3+2*n!1"))
Applying expt_pos where 
  px gets 1 - sq(z!1),
  i gets 3 + 2 * n!1,
this yields  2 subgoals: 
atanh_series.1.1.1 :  

{-1}  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (lemma "posreal_times_posreal_is_posreal"
                 ("px" "6+4*n!1" "py" "(1 - sq(z!1)) ^ (3 + 2 * n!1)"))
Applying posreal_times_posreal_is_posreal where 
  px gets 6 + 4 * n!1,
  py gets (1 - sq(z!1)) ^ (3 + 2 * n!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1 :  

{-1}  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (case "atanhND(1 + n!1)(c!1)>0")
Case splitting on 
   atanhND(1 + n!1)(c!1) > 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(c!1) > 0
[-2]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (case "abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)")
Case splitting on 
   abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1 :  

{-1}  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-2]  atanhND(1 + n!1)(c!1) > 0
[-3]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (case "atanhND(1 + n!1)(z!1) = factorial(2+2*n!1)*(((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) / (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))")
Case splitting on 
   atanhND(1 + n!1)(z!1) =
    factorial(2 + 2 * n!1) *
     (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
       (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))), 
this yields  3 subgoals: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
[-2]  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (rewrite "div_mult_pos_le1" 1)
Found matching substitution:
x gets ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1)),
py: posreal gets factorial(3 + 2 * n!1),
z: real gets abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)),
Rewriting using div_mult_pos_le1, matching in 1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
[-2]  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
           4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (expand "abs" 1 1)
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
[-2]  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   IF atanhND(1 + n!1)(c!1) < 0 THEN -atanhND(1 + n!1)(c!1)
      ELSE atanhND(1 + n!1)(c!1)
      ENDIF
       * abs(z!1 ^ (3 + 2 * n!1))
       <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
           4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (expand "abs" -2)
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
{-2}  IF atanhND(1 + n!1)(c!1) < 0 THEN -atanhND(1 + n!1)(c!1)
      ELSE atanhND(1 + n!1)(c!1)
      ENDIF
       <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   IF atanhND(1 + n!1)(c!1) < 0 THEN -atanhND(1 + n!1)(c!1)
      ELSE atanhND(1 + n!1)(c!1)
      ENDIF
       * abs(z!1 ^ (3 + 2 * n!1))
       <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
           4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
{-2}  atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
{-4}  6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
       4 * ((1 - sq(z!1)) ^ (3 + 2 * n!1) * n!1)
       > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
           4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (name-replace "K10" "1 - sq(z!1)")
Using K10 to name and replace 1 - sq(z!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * K10 ^ (3 + 2 * n!1)))
[-2]  atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
{-4}  6 * K10 ^ (3 + 2 * n!1) + 4 * (K10 ^ (3 + 2 * n!1) * n!1) > 0
{-5}  K10 ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
{-7}  K10 > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * K10 ^ (3 + 2 * n!1) + 4 * ((K10 ^ (3 + 2 * n!1)) * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (name-replace "K11" "K10^(3+2*n!1)")
Using K11 to name and replace K10^(3+2*n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * K11))
[-2]  atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
{-4}  6 * K11 + 4 * (K11 * n!1) > 0
{-5}  K11 > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  K10 > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
         (6 * K11 + 4 * (K11 * n!1)))
        * factorial(3 + 2 * n!1)

Rerunning step: (name-replace "K12"
                 "(1-z!1)^(3+2*n!1)+(1+z!1)^(3+2*n!1)")
Using K12 to name and replace (1-z!1)^(3+2*n!1)+(1+z!1)^(3+2*n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-2]  atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  6 * K11 + 4 * (K11 * n!1) > 0
[-5]  K11 > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  K10 > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (K12 / (6 * K11 + 4 * (K11 * n!1))) * factorial(3 + 2 * n!1)

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
{-2}  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) > 0
[-4]  6 * K11 + 4 * (K11 * n!1) > 0
[-5]  K11 > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  K10 > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (K12 / (6 * K11 + 4 * (K11 * n!1))) * factorial(3 + 2 * n!1)

Rerunning step: (lemma "lt_times_lt_pos1"
                 ("px" "atanhND(1 + n!1)(c!1)" "y"
                  "factorial(2 + 2 * n!1) * (K12 / (2 * K11))" "nnz"
                  "abs(z!1 ^ (3 + 2 * n!1))" "w" "1"))
Applying lt_times_lt_pos1 where 
  px gets atanhND(1 + n!1)(c!1),
  y gets factorial(2 + 2 * n!1) * (K12 / (2 * K11)),
  nnz gets abs(z!1 ^ (3 + 2 * n!1)),
  w gets 1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
       AND abs(z!1 ^ (3 + 2 * n!1)) < 1
       IMPLIES
       atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
        factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1
[-2]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-4]  atanhND(1 + n!1)(c!1) > 0
[-5]  6 * K11 + 4 * (K11 * n!1) > 0
[-6]  K11 > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  K10 > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (K12 / (6 * K11 + 4 * (K11 * n!1))) * factorial(3 + 2 * n!1)

Rerunning step: (replace -3)
Replacing using formula -3,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  abs(z!1 ^ (3 + 2 * n!1)) < 1 IMPLIES
       atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
        factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1
[-2]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-4]  atanhND(1 + n!1)(c!1) > 0
[-5]  6 * K11 + 4 * (K11 * n!1) > 0
[-6]  K11 > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  K10 > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (K12 / (6 * K11 + 4 * (K11 * n!1))) * factorial(3 + 2 * n!1)

Rerunning step: (replace -7)
Replacing using formula -7,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

{-1}  atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
       factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1
[-2]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-4]  atanhND(1 + n!1)(c!1) > 0
[-5]  6 * K11 + 4 * (K11 * n!1) > 0
[-6]  K11 > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  K10 > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       (K12 / (6 * K11 + 4 * (K11 * n!1))) * factorial(3 + 2 * n!1)

Rerunning step: (expand "factorial" 1)
Expanding the definition of factorial,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1 :  

[-1]  atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
       factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1
[-2]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-4]  atanhND(1 + n!1)(c!1) > 0
[-5]  6 * K11 + 4 * (K11 * n!1) > 0
[-6]  K11 > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  K10 > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (case-replace
                 "factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 = 3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)")
Assuming and applying factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 = 3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.1.1 :  

{-1}  factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)
{-2}  atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)
{-3}  atanhND(1 + n!1)(z!1) =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)
{-4}  atanhND(1 + n!1)(c!1) <=
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)
[-5]  atanhND(1 + n!1)(c!1) > 0
[-6]  6 * K11 + 4 * (K11 * n!1) > 0
[-7]  K11 > 0
[-8]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-9]  K10 > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.1.1.2 :  

[-1]  atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <
       factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1
[-2]  atanhND(1 + n!1)(z!1) = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-3]  atanhND(1 + n!1)(c!1) <= factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-4]  atanhND(1 + n!1)(c!1) > 0
[-5]  6 * K11 + 4 * (K11 * n!1) > 0
[-6]  K11 > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  K10 > 0
  |-------
{1}   factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)
[2]   atanhND(1 + n!1)(c!1) * abs(z!1 ^ (3 + 2 * n!1)) <=
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (hide-all-but (-5 -6 1))
Keeping (-5 -6 1) and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
[1]   factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (lemma "div_cancel1"
                 ("x" "factorial(2 + 2 * n!1) * (K12 / (2 * K11))"
                  "n0z" "3+2*n!1"))
Applying div_cancel1 where 
  x gets factorial(2 + 2 * n!1) * (K12 / (2 * K11)),
  n0z gets 3 + 2 * n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2 :  

{-1}  (3 + 2 * n!1) *
       (factorial(2 + 2 * n!1) * (K12 / (2 * K11)) / (3 + 2 * n!1))
       = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-2]  6 * K11 + 4 * (K11 * n!1) > 0
[-3]  K11 > 0
  |-------
[1]   factorial(2 + 2 * n!1) * (K12 / (2 * K11)) * 1 =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (replace -1 1 rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2 :  

[-1]  (3 + 2 * n!1) *
       (factorial(2 + 2 * n!1) * (K12 / (2 * K11)) / (3 + 2 * n!1))
       = factorial(2 + 2 * n!1) * (K12 / (2 * K11))
[-2]  6 * K11 + 4 * (K11 * n!1) > 0
[-3]  K11 > 0
  |-------
{1}   (3 + 2 * n!1) *
       (factorial(2 + 2 * n!1) * (K12 / (2 * K11)) / (3 + 2 * n!1))
       =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
[1]   (3 + 2 * n!1) *
       (factorial(2 + 2 * n!1) * (K12 / (2 * K11)) / (3 + 2 * n!1))
       =
       3 * (factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 *
         ((factorial(2 + 2 * n!1) * (K12 / (6 * K11 + 4 * (K11 * n!1)))) *
           n!1)

Rerunning step: (name-replace "K13" "factorial(2 + 2 * n!1)")
Using K13 to name and replace factorial(2 + 2 * n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
{1}   (3 + 2 * n!1) * (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       3 * (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 * ((K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) * n!1)

Rerunning step: (case-replace
                 "(K13 * (K12 / (2 * K11)) / (3 + 2 * n!1))=(K13 * (K12 / (6 * K11 + 4 * (K11 * n!1))))")
Assuming and applying (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1))=(K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.1.2.1 :  

{-1}  (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1))))
[-2]  6 * K11 + 4 * (K11 * n!1) > 0
[-3]  K11 > 0
  |-------
{1}   (3 + 2 * n!1) * (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) =
       3 * (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 * ((K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.1.1.2.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
{1}   (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1))))
[2]   (3 + 2 * n!1) * (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       3 * (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) +
        2 * ((K13 * (K12 / (6 * K11 + 4 * (K11 * n!1)))) * n!1)

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
[1]   (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1))))

Rerunning step: (lemma "cross_mult"
                 ("x" "K13 * (K12 / (2 * K11))" "n0x" "3+2*n!1" "y"
                  "K13*K12" "n0y" "6 * K11 + 4 * (K11 * n!1)"))
Applying cross_mult where 
  x gets K13 * (K12 / (2 * K11)),
  n0x gets 3 + 2 * n!1,
  y gets K13 * K12,
  n0y gets 6 * K11 + 4 * (K11 * n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2.2 :  

{-1}  (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1) =
        K13 * K12 / (6 * K11 + 4 * (K11 * n!1)))
       IFF
       (K13 * (K12 / (2 * K11)) * (6 * K11 + 4 * (K11 * n!1)) =
         K13 * K12 * (3 + 2 * n!1))
[-2]  6 * K11 + 4 * (K11 * n!1) > 0
[-3]  K11 > 0
  |-------
[1]   (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1)) =
       (K13 * (K12 / (6 * K11 + 4 * (K11 * n!1))))

Rerunning step: (replace -1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2.2 :  

[-1]  (K13 * (K12 / (2 * K11)) / (3 + 2 * n!1) =
        K13 * K12 / (6 * K11 + 4 * (K11 * n!1)))
       IFF
       (K13 * (K12 / (2 * K11)) * (6 * K11 + 4 * (K11 * n!1)) =
         K13 * K12 * (3 + 2 * n!1))
[-2]  6 * K11 + 4 * (K11 * n!1) > 0
[-3]  K11 > 0
  |-------
{1}   (K13 * (K12 / (2 * K11)) * (6 * K11 + 4 * (K11 * n!1)) =
        K13 * K12 * (3 + 2 * n!1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.1.2.2 :  

[-1]  6 * K11 + 4 * (K11 * n!1) > 0
[-2]  K11 > 0
  |-------
[1]   (K13 * (K12 / (2 * K11)) * (6 * K11 + 4 * (K11 * n!1)) =
        K13 * K12 * (3 + 2 * n!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.1.2 :  

[-1]  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-2]  atanhND(1 + n!1)(c!1) > 0
[-3]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
{1}   atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide -1 -2 2)
Hiding formulas:  -1, -2, 2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   atanhND(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (expand "atanhND")
Expanding the definition of atanhND,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   atanhN(1 + n!1)(z!1) / atanhD(1 + n!1)(z!1) =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (expand "atanhN")
Expanding the definition of atanhN,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) / atanhD(1 + n!1)(z!1)
       =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (expand "atanhD")
Expanding the definition of atanhD,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (lemma "cross_mult"
                 ("x" "polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1)"
                  "n0x" "(1 - sq(z!1)) ^ (3 + 2 * n!1)" "y"
                  "factorial(2 + 2 * n!1) * ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))"
                  "n0y" "2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)"))
Applying cross_mult where 
  x gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1),
  n0x gets (1 - sq(z!1)) ^ (3 + 2 * n!1),
  y gets factorial(2 + 2 * n!1) *
          ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)),
  n0y gets 2 * (1 - sq(z!1)) ^ (3 + 2 * n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

{-1}  (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         / (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
       IFF
       (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
         (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
         =
         factorial(2 + 2 * n!1) *
          ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
          * (1 - sq(z!1)) ^ (3 + 2 * n!1))
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       =
       factorial(2 + 2 * n!1) *
        (((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
          (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         / (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)))
       IFF
       (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
         (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
         =
         factorial(2 + 2 * n!1) *
          ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
          * (1 - sq(z!1)) ^ (3 + 2 * n!1))
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))

Rerunning step: (lemma "both_sides_times1"
                 ("x"
                  "polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2"
                  "n0z" "(1 - sq(z!1)) ^ (3 + 2 * n!1)" "y"
                  "factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))"))
Applying both_sides_times1 where 
  x gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2,
  n0z gets (1 - sq(z!1)) ^ (3 + 2 * n!1),
  y gets factorial(2 + 2 * n!1) *
          ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1 :  

{-1}  (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 *
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))
       IFF
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1 :  

[-1]  (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 *
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))
       IFF
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (hide -1 -2)
Hiding formulas:  -1, -2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (lemma "power_polynomial" ("pn" "3+2*n!1"))
Applying power_polynomial where 
  pn gets 3 + 2 * n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1 :  

{-1}  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-2]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (lemma "neg_power_polynomial" ("pn" "3+2*n!1"))
Applying neg_power_polynomial where 
  pn gets 3 + 2 * n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1 :  

{-1}  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-2]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (case-replace
                 "(1 - z!1) ^ (3 + 2 * n!1) = polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)")
Assuming and applying (1 - z!1) ^ (3 + 2 * n!1) = polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1 :  

{-1}  (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-2]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-4]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (case-replace
                 "(1 + z!1) ^ (3 + 2 * n!1) = polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)")
Assuming and applying (1 + z!1) ^ (3 + 2 * n!1) = polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  (1 + z!1) ^ (3 + 2 * n!1) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-2]  (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-3]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-4]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-5]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1))

Rerunning step: (hide -1 -2 -3 -4)
Hiding formulas:  -1, -2, -3, -4,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1))

Rerunning step: (expand "polynomial")
Expanding the definition of polynomial,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i: nat):
               atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (lemma "sigma_scal[nat]"
                 ("low" "0" "high" "2+2*n!1" "a" "2" "F"
                  "LAMBDA (i: nat):
               atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF)"))
Free variables in expr i
Applying sigma_scal[nat] where 
  low gets 0,
  high gets 2 + 2 * n!1,
  a gets 2,
  F gets LAMBDA (i: nat):
           atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       2 *
        sigma(0, 2 + 2 * n!1,
              LAMBDA (i: nat):
                atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   2 *
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i: nat):
               atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (replace -1 1 rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       2 *
        sigma(0, 2 + 2 * n!1,
              LAMBDA (i: nat):
                atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (lemma "sigma_scal[nat]"
                 ("low" "0" "high" "3+2*n!1" "a"
                  "factorial(2 + 2 * n!1)" "F"
                  "LAMBDA (i: nat):power_fs(3 + 2 * n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF)"))
Free variables in expr i
Ignoring 1 repeated TCCs.
Applying sigma_scal[nat] where 
  low gets 0,
  high gets 3 + 2 * n!1,
  a gets factorial(2 + 2 * n!1),
  F gets LAMBDA (i: nat):
           power_fs(3 + 2 * n!1)(i) *
            (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (replace -1 1 rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (lemma "sigma_scal[nat]"
                 ("low" "0" "high" "3+2*n!1" "a"
                  "factorial(2 + 2 * n!1)" "F"
                  "LAMBDA (i: nat):neg_power_fs(3 + 2 * n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF)"))
Free variables in expr i
Ignoring 1 repeated TCCs.
Applying sigma_scal[nat] where 
  low gets 0,
  high gets 3 + 2 * n!1,
  a gets factorial(2 + 2 * n!1),
  F gets LAMBDA (i: nat):
           neg_power_fs(3 + 2 * n!1)(i) *
            (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  neg_power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                neg_power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        factorial(2 + 2 * n!1) *
         sigma(0, 3 + 2 * n!1,
               LAMBDA (i: nat):
                 neg_power_fs(3 + 2 * n!1)(i) *
                  (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))

Rerunning step: (replace -1 1 rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  neg_power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       factorial(2 + 2 * n!1) *
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i: nat):
                neg_power_fs(3 + 2 * n!1)(i) *
                 (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i_1: nat):
                factorial(2 + 2 * n!1) *
                 (LAMBDA (i: nat):
                    neg_power_fs(3 + 2 * n!1)(i) *
                     (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                     (i_1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i_1: nat):
                factorial(2 + 2 * n!1) *
                 (LAMBDA (i: nat):
                    neg_power_fs(3 + 2 * n!1)(i) *
                     (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                     (i_1))

Rerunning step: (lemma "sigma_sum"
                 ("low" "0" "high" "3+2*n!1" "F" "LAMBDA (i: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))(i)" "G"
                  "LAMBDA (i: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   neg_power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))(i)"))
Free variables in expr i
Free variables in expr i
Applying sigma_sum where 
  low gets 0,
  high gets 3 + 2 * n!1,
  F gets LAMBDA (i: nat):
           factorial(2 + 2 * n!1) *
            (LAMBDA (i: nat):
               power_fs(3 + 2 * n!1)(i) *
                (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                (i),
  G gets LAMBDA (i: nat):
           factorial(2 + 2 * n!1) *
            (LAMBDA (i: nat):
               neg_power_fs(3 + 2 * n!1)(i) *
                (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                (i),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  sigma(0, 3 + 2 * n!1,
            LAMBDA (i: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i))
       +
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   neg_power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               (LAMBDA (i: nat):
                  factorial(2 + 2 * n!1) *
                   (LAMBDA (i: nat):
                      power_fs(3 + 2 * n!1)(i) *
                       (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                       (i))
                   (i_1)
                +
                (LAMBDA (i: nat):
                   factorial(2 + 2 * n!1) *
                    (LAMBDA (i: nat):
                       neg_power_fs(3 + 2 * n!1)(i) *
                        (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                        (i))
                    (i_1))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i_1))
        +
        sigma(0, 3 + 2 * n!1,
              LAMBDA (i_1: nat):
                factorial(2 + 2 * n!1) *
                 (LAMBDA (i: nat):
                    neg_power_fs(3 + 2 * n!1)(i) *
                     (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                     (i_1))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  sigma(0, 3 + 2 * n!1,
            LAMBDA (i: nat):
              factorial(2 + 2 * n!1) *
               (LAMBDA (i: nat):
                  power_fs(3 + 2 * n!1)(i) *
                   (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i))
       +
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i: nat):
               factorial(2 + 2 * n!1) *
                (LAMBDA (i: nat):
                   neg_power_fs(3 + 2 * n!1)(i) *
                    (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                    (i))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               (LAMBDA (i: nat):
                  factorial(2 + 2 * n!1) *
                   (LAMBDA (i: nat):
                      power_fs(3 + 2 * n!1)(i) *
                       (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                       (i))
                   (i_1)
                +
                (LAMBDA (i: nat):
                   factorial(2 + 2 * n!1) *
                    (LAMBDA (i: nat):
                       neg_power_fs(3 + 2 * n!1)(i) *
                        (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                        (i))
                    (i_1))
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               (LAMBDA (i: nat):
                  factorial(2 + 2 * n!1) *
                   (LAMBDA (i: nat):
                      power_fs(3 + 2 * n!1)(i) *
                       (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                       (i))
                   (i_1)
                +
                (LAMBDA (i: nat):
                   factorial(2 + 2 * n!1) *
                    (LAMBDA (i: nat):
                       neg_power_fs(3 + 2 * n!1)(i) *
                        (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                        (i))
                    (i_1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (LAMBDA (i: nat):
                  atanhF(1 + n!1)(i) * (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                   (i_1))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               (LAMBDA (i: nat):
                  factorial(2 + 2 * n!1) *
                   (LAMBDA (i: nat):
                      power_fs(3 + 2 * n!1)(i) *
                       (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                       (i))
                   (i_1)
                +
                (LAMBDA (i: nat):
                   factorial(2 + 2 * n!1) *
                    (LAMBDA (i: nat):
                       neg_power_fs(3 + 2 * n!1)(i) *
                        (IF i = 0 THEN 1 ELSE z!1 ^ i ENDIF))
                        (i))
                    (i_1))

Rerunning step: (simplify 1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (lemma "sigma_last"
                 ("low" "0" "high" "3+2*n!1" "F" "LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))"))
Free variables in expr i_1
Free variables in expr i_1
Ignoring 1 repeated TCCs.
Applying sigma_last where 
  low gets 0,
  high gets 3 + 2 * n!1,
  F gets LAMBDA (i_1: nat):
           factorial(2 + 2 * n!1) *
            (power_fs(3 + 2 * n!1)(i_1) *
              (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
            +
            factorial(2 + 2 * n!1) *
             (neg_power_fs(3 + 2 * n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  3 + 2 * n!1 > 0 IMPLIES
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        =
        sigma(0, 3 + 2 * n!1 - 1,
              LAMBDA (i_1: nat):
                factorial(2 + 2 * n!1) *
                 (power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                 +
                 factorial(2 + 2 * n!1) *
                  (neg_power_fs(3 + 2 * n!1)(i_1) *
                    (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
         +
         (LAMBDA (i_1: nat):
            factorial(2 + 2 * n!1) *
             (power_fs(3 + 2 * n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
             +
             factorial(2 + 2 * n!1) *
              (neg_power_fs(3 + 2 * n!1)(i_1) *
                (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
             (3 + 2 * n!1)
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

{-1}  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 3 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  sigma(0, 3 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))

Rerunning step: (expand "neg_power_fs" 1 2)
Expanding the definition of neg_power_fs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (power_fs(3 + 2 * n!1)(3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         ((C(3 + 2 * n!1, 3 + 2 * n!1) * (-1) ^ (3 + 2 * n!1)) *
           z!1 ^ (3 + 2 * n!1))

Rerunning step: (expand "power_fs" 1 2)
Expanding the definition of power_fs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         ((C(3 + 2 * n!1, 3 + 2 * n!1) * (-1) ^ (3 + 2 * n!1)) *
           z!1 ^ (3 + 2 * n!1))

Rerunning step: (case-replace "(-1) ^ (3 + 2 * n!1)=-1")
Assuming and applying (-1) ^ (3 + 2 * n!1)=-1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1 :  

{-1}  (-1) ^ (3 + 2 * n!1) = -1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1))

Rerunning step: (case-replace "sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1)) = sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))")
Assuming and applying sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1)) = sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1 :  

{-1}  sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
[-2]  (-1) ^ (3 + 2 * n!1) = -1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (hide -1 -2)
Hiding formulas:  -1, -2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (lemma "sigma_eq[nat]"
                 ("low" "0" "high" "2+2*n!1" "F" "LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))" "G"
                  "LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))"))
Free variables in expr i_1
Free variables in expr i_1
Free variables in expr i_1
Ignoring 1 repeated TCCs.
Applying sigma_eq[nat] where 
  low gets 0,
  high gets 2 + 2 * n!1,
  F gets LAMBDA (i_1: nat):
           2 *
            (atanhF(1 + n!1)(i_1) *
              (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)),
  G gets LAMBDA (i_1: nat):
           factorial(2 + 2 * n!1) *
            (power_fs(3 + 2 * n!1)(i_1) *
              (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
            +
            factorial(2 + 2 * n!1) *
             (neg_power_fs(3 + 2 * n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1 :  

{-1}  (FORALL (n: subrange(0, 2 + 2 * n!1)):
         (LAMBDA (i_1: nat):
            2 *
             (atanhF(1 + n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
             (n)
          =
          (LAMBDA (i_1: nat):
             factorial(2 + 2 * n!1) *
              (power_fs(3 + 2 * n!1)(i_1) *
                (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
              +
              factorial(2 + 2 * n!1) *
               (neg_power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
              (n))
       IMPLIES
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               2 *
                (atanhF(1 + n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        =
        sigma(0, 2 + 2 * n!1,
              LAMBDA (i_1: nat):
                factorial(2 + 2 * n!1) *
                 (power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                 +
                 factorial(2 + 2 * n!1) *
                  (neg_power_fs(3 + 2 * n!1)(i_1) *
                    (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.1 :  

{-1}  sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   FORALL (n: subrange(0, 2 + 2 * n!1)):
        (LAMBDA (i_1: nat):
           2 *
            (atanhF(1 + n!1)(i_1) *
              (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
            (n)
         =
         (LAMBDA (i_1: nat):
            factorial(2 + 2 * n!1) *
             (power_fs(3 + 2 * n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
             +
             factorial(2 + 2 * n!1) *
              (neg_power_fs(3 + 2 * n!1)(i_1) *
                (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
             (n)
[2]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
[1]   FORALL (n: subrange(0, 2 + 2 * n!1)):
        (LAMBDA (i_1: nat):
           2 *
            (atanhF(1 + n!1)(i_1) *
              (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
            (n)
         =
         (LAMBDA (i_1: nat):
            factorial(2 + 2 * n!1) *
             (power_fs(3 + 2 * n!1)(i_1) *
               (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
             +
             factorial(2 + 2 * n!1) *
              (neg_power_fs(3 + 2 * n!1)(i_1) *
                (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
             (n)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 * (atanhF(1 + n!1)(n!2) * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       factorial(2 + 2 * n!1) *
        (power_fs(3 + 2 * n!1)(n!2) *
          (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(n!2) *
           (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       (IF odd?(n!2) THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, n!2)
        ENDIF
         * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       factorial(2 + 2 * n!1) *
        (power_fs(3 + 2 * n!1)(n!2) *
          (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(n!2) *
           (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (expand "power_fs")
Expanding the definition of power_fs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       (IF odd?(n!2) THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, n!2)
        ENDIF
         * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, n!2) * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
        +
        factorial(2 + 2 * n!1) *
         (neg_power_fs(3 + 2 * n!1)(n!2) *
           (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (expand "neg_power_fs")
Expanding the definition of neg_power_fs,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       (IF odd?(n!2) THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, n!2)
        ENDIF
         * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, n!2) * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, n!2) * (-1) ^ n!2 *
           (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (name-replace "K400" "factorial(2 + 2 * n!1)")
Using K400 to name and replace factorial(2 + 2 * n!1),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       (IF odd?(n!2) THEN 0 ELSE K400 * C(3 + 2 * n!1, n!2) ENDIF *
         (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       K400 *
        (C(3 + 2 * n!1, n!2) * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
        +
        K400 *
         (C(3 + 2 * n!1, n!2) * (-1) ^ n!2 *
           (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (name-replace "K401" "C(3 + 2 * n!1, n!2)")
Using K401 to name and replace C(3 + 2 * n!1, n!2),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 *
       (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF *
         (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))
       =
       K400 * (K401 * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF)) +
        K400 *
         (K401 * (-1) ^ n!2 * (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF))

Rerunning step: (name-replace "K402"
                 "(IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF)")
Using K402 to name and replace (IF n!2 = 0 THEN 1 ELSE z!1 ^ n!2 ENDIF),
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   2 * (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF * K402) =
       K400 * (K401 * K402) + K400 * (K401 * (-1) ^ n!2 * K402)

Rerunning step: (case "even?(n!2)")
Case splitting on 
   even?(n!2), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

{-1}  even?(n!2)
[-2]  1 - sq(z!1) > 0
  |-------
[1]   2 * (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF * K402) =
       K400 * (K401 * K402) + K400 * (K401 * (-1) ^ n!2 * K402)

Rerunning step: (lemma "even_or_odd" ("x" "n!2"))
Applying even_or_odd where 
  x gets n!2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

{-1}  even?(n!2) IFF NOT odd?(n!2)
[-2]  even?(n!2)
[-3]  1 - sq(z!1) > 0
  |-------
[1]   2 * (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF * K402) =
       K400 * (K401 * K402) + K400 * (K401 * (-1) ^ n!2 * K402)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

[-1]  even?(n!2)
[-2]  1 - sq(z!1) > 0
  |-------
{1}   odd?(n!2)
{2}   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (expand "even?")
Expanding the definition of even?,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

{-1}  EXISTS j: n!2 = 2 * j
[-2]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
[2]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

{-1}  n!2 = 2 * j!1
[-2]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
[2]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (replace -1 2)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

[-1]  n!2 = 2 * j!1
[-2]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
{2}   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ (2 * j!1) * K401 * K402)

Rerunning step: (lemma "expt_times" ("n0x" "-1" "i" "2" "j" "j!1"))
Applying expt_times where 
  n0x gets -1,
  i gets 2,
  j gets j!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

{-1}  (-1) ^ (2 * j!1) = ((-1) ^ 2) ^ j!1
[-2]  n!2 = 2 * j!1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
[2]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ (2 * j!1) * K401 * K402)

Rerunning step: (case-replace "(-1)^2=1")
Assuming and applying (-1)^2=1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.1 :  

{-1}  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * j!1) = 1 ^ j!1
[-3]  n!2 = 2 * j!1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
[2]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ (2 * j!1) * K401 * K402)

Rerunning step: (rewrite "expt_1i")
Found matching substitution:
i: int gets j!1,
Rewriting using expt_1i, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.1 :  

[-1]  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * j!1) = 1
[-3]  n!2 = 2 * j!1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   odd?(n!2)
[2]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ (2 * j!1) * K401 * K402)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.2 :  

[-1]  (-1) ^ (2 * j!1) = ((-1) ^ 2) ^ j!1
[-2]  n!2 = 2 * j!1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   (-1) ^ 2 = 1
[2]   odd?(n!2)
[3]   2 * (K400 * K401 * K402) =
       K400 * (K401 * K402) + K400 * ((-1) ^ (2 * j!1) * K401 * K402)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.2 :  

  |-------
[1]   (-1) ^ 2 = 1

Rerunning step: (grind)
expt rewrites expt((-1), 0)
  to 1
expt rewrites expt((-1), 1)
  to -1
expt rewrites expt((-1), 2)
  to (-1) * -1
^ rewrites (-1) ^ 2
  to (-1) * -1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   even?(n!2)
[2]   2 * (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF * K402) =
       K400 * (K401 * K402) + K400 * (K401 * (-1) ^ n!2 * K402)

Rerunning step: (rewrite "even_or_odd" 1)
Found matching substitution:
x: int gets n!2,
Rewriting using even_or_odd, matching in 1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  odd?(n!2)
[-2]  1 - sq(z!1) > 0
  |-------
[1]   2 * (IF odd?(n!2) THEN 0 ELSE K400 * K401 ENDIF * K402) =
       K400 * (K401 * K402) + K400 * (K401 * (-1) ^ n!2 * K402)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

[-1]  odd?(n!2)
[-2]  1 - sq(z!1) > 0
  |-------
{1}   0 = K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  EXISTS j: n!2 = 1 + 2 * j
[-2]  1 - sq(z!1) > 0
  |-------
[1]   0 = K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  n!2 = 1 + 2 * j!1
[-2]  1 - sq(z!1) > 0
  |-------
[1]   0 = K400 * (K401 * K402) + K400 * ((-1) ^ n!2 * K401 * K402)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

[-1]  n!2 = 1 + 2 * j!1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (lemma "expt_plus" ("n0x" "-1" "i" "1" "j" "2*j!1"))
Applying expt_plus where 
  n0x gets -1,
  i gets 1,
  j gets 2 * j!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  (-1) ^ (1 + 2 * j!1) = (-1) ^ 1 * (-1) ^ (2 * j!1)
[-2]  n!2 = 1 + 2 * j!1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (rewrite "expt_x1")
Found matching substitution:
x: real gets -1,
Rewriting using expt_x1, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  (-1) ^ (1 + 2 * j!1) = -1 * (-1) ^ (2 * j!1)
[-2]  n!2 = 1 + 2 * j!1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (lemma "expt_times" ("n0x" "-1" "i" "2" "j" "j!1"))
Applying expt_times where 
  n0x gets -1,
  i gets 2,
  j gets j!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  (-1) ^ (2 * j!1) = ((-1) ^ 2) ^ j!1
[-2]  (-1) ^ (1 + 2 * j!1) = -1 * (-1) ^ (2 * j!1)
[-3]  n!2 = 1 + 2 * j!1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (case-replace "(-1)^2=1")
Assuming and applying (-1)^2=1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.1 :  

{-1}  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * j!1) = 1 ^ j!1
[-3]  (-1) ^ (1 + 2 * j!1) = -1 * (-1) ^ (2 * j!1)
[-4]  n!2 = 1 + 2 * j!1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (rewrite "expt_1i")
Found matching substitution:
i: int gets j!1,
Rewriting using expt_1i, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.1 :  

[-1]  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * j!1) = 1
[-3]  (-1) ^ (1 + 2 * j!1) = -1 * (-1) ^ (2 * j!1)
[-4]  n!2 = 1 + 2 * j!1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

[-1]  (-1) ^ (2 * j!1) = ((-1) ^ 2) ^ j!1
[-2]  (-1) ^ (1 + 2 * j!1) = -1 * (-1) ^ (2 * j!1)
[-3]  n!2 = 1 + 2 * j!1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   (-1) ^ 2 = 1
[2]   0 =
       K400 * (K401 * K402) + K400 * (((-1) ^ (1 + 2 * j!1)) * K401 * K402)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

  |-------
[1]   (-1) ^ 2 = 1

Rerunning step: (grind)
expt rewrites expt((-1), 0)
  to 1
expt rewrites expt((-1), 1)
  to -1
expt rewrites expt((-1), 2)
  to (-1) * -1
^ rewrites (-1) ^ 2
  to (-1) * -1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.1.2 :  

[-1]  (-1) ^ (3 + 2 * n!1) = -1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
[2]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1))

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.1.2 :  

[-1]  (-1) ^ (3 + 2 * n!1) = -1
[-2]  1 - sq(z!1) > 0
  |-------
[1]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
       +
       factorial(2 + 2 * n!1) *
        (C(3 + 2 * n!1, 3 + 2 * n!1) * -1 * z!1 ^ (3 + 2 * n!1))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))

Rerunning step: (name-replace "K300" "sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))")
Using K300 to name and replace sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              factorial(2 + 2 * n!1) *
               (power_fs(3 + 2 * n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
               +
               factorial(2 + 2 * n!1) *
                (neg_power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))),

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   (-1) ^ (3 + 2 * n!1) = -1
[2]   sigma(0, 2 + 2 * n!1,
            LAMBDA (i_1: nat):
              2 *
               (atanhF(1 + n!1)(i_1) *
                 (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
       =
       sigma(0, 2 + 2 * n!1,
             LAMBDA (i_1: nat):
               factorial(2 + 2 * n!1) *
                (power_fs(3 + 2 * n!1)(i_1) *
                  (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF))
                +
                factorial(2 + 2 * n!1) *
                 (neg_power_fs(3 + 2 * n!1)(i_1) *
                   (IF i_1 = 0 THEN 1 ELSE z!1 ^ i_1 ENDIF)))
        +
        factorial(2 + 2 * n!1) *
         (C(3 + 2 * n!1, 3 + 2 * n!1) * z!1 ^ (3 + 2 * n!1))
        +
        factorial(2 + 2 * n!1) *
         ((C(3 + 2 * n!1, 3 + 2 * n!1) * (-1) ^ (3 + 2 * n!1)) *
           z!1 ^ (3 + 2 * n!1))

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (lemma "expt_plus" ("n0x" "-1" "i" "1" "j" "2+2*n!1"))
Applying expt_plus where 
  n0x gets -1,
  i gets 1,
  j gets 2 + 2 * n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

{-1}  (-1) ^ (1 + (2 + 2 * n!1)) = (-1) ^ 1 * (-1) ^ (2 + 2 * n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (rewrite "expt_x1")
Found matching substitution:
x: real gets -1,
Rewriting using expt_x1, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

{-1}  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * (-1) ^ (2 + 2 * n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (lemma "expt_times")
Applying expt_times 
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

{-1}  FORALL (i, j: int, n0x: nzreal): n0x ^ (i * j) = (n0x ^ i) ^ j
[-2]  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * (-1) ^ (2 + 2 * n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (inst - "2" "1+n!1" "-1")
Instantiating the top quantifier in - with the terms: 
 2, 1+n!1, -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

{-1}  (-1) ^ (2 * (1 + n!1)) = ((-1) ^ 2) ^ (1 + n!1)
[-2]  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * (-1) ^ (2 + 2 * n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2 :  

[-1]  (-1) ^ (2 * (1 + n!1)) = ((-1) ^ 2) ^ (1 + n!1)
{-2}  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * ((-1) ^ 2) ^ (1 + n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (case-replace "(-1)^2=1")
Assuming and applying (-1)^2=1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2.1 :  

{-1}  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * (1 + n!1)) = 1 ^ (1 + n!1)
{-3}  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * 1 ^ (1 + n!1)
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (rewrite "expt_1i" -2)
Found matching substitution:
i: int gets 1 + n!1,
Rewriting using expt_1i, matching in -2,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2.1 :  

[-1]  (-1) ^ 2 = 1
{-2}  (-1) ^ (2 * (1 + n!1)) = 1
{-3}  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * 1
  |-------
[1]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.2.1.

atanh_series.1.1.1.1.1.1.2.1.1.1.2.2 :  

[-1]  (-1) ^ (2 * (1 + n!1)) = ((-1) ^ 2) ^ (1 + n!1)
[-2]  (-1) ^ (1 + (2 + 2 * n!1)) = -1 * ((-1) ^ 2) ^ (1 + n!1)
  |-------
{1}   (-1) ^ 2 = 1
[2]   (-1) ^ (3 + 2 * n!1) = -1

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.1.2.2 :  

  |-------
[1]   (-1) ^ 2 = 1

Rerunning step: (grind)
expt rewrites expt((-1), 0)
  to 1
expt rewrites expt((-1), 1)
  to -1
expt rewrites expt((-1), 2)
  to (-1) * -1
^ rewrites (-1) ^ 2
  to (-1) * -1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.1.

atanh_series.1.1.1.1.1.1.2.1.1.2 :  

[-1]  (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-2]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-4]  1 - sq(z!1) > 0
  |-------
{1}   (1 + z!1) ^ (3 + 2 * n!1) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (replace -3 1 rl)
Replacing using formula -3,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.2 :  

[-1]  (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-2]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-4]  1 - sq(z!1) > 0
  |-------
{1}   (1 + z!1) ^ (3 + 2 * n!1) =
       (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1))(z!1)
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (simplify 1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.1.2 :  

[-1]  (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[-2]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-4]  1 - sq(z!1) > 0
  |-------
{1}   TRUE
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        (polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1) +
          (1 + z!1) ^ (3 + 2 * n!1))

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.1.

atanh_series.1.1.1.1.1.1.2.1.2 :  

[-1]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-2]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  1 - sq(z!1) > 0
  |-------
{1}   (1 - z!1) ^ (3 + 2 * n!1) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)(z!1)
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (replace -1 1 rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.2 :  

[-1]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-2]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  1 - sq(z!1) > 0
  |-------
{1}   (1 - z!1) ^ (3 + 2 * n!1) =
       (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1))(z!1)
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

Rerunning step: (simplify 1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.1.2.1.2 :  

[-1]  (LAMBDA (x: real): (1 - x) ^ (3 + 2 * n!1)) =
       polynomial(neg_power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-2]  (LAMBDA (x: real): (1 + x) ^ (3 + 2 * n!1)) =
       polynomial(power_fs(3 + 2 * n!1), 3 + 2 * n!1)
[-3]  1 - sq(z!1) > 0
  |-------
{1}   TRUE
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) * 2 =
       factorial(2 + 2 * n!1) *
        ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.1.1.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.1.2.2 (TCC):   

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   (1 - sq(z!1)) ^ (3 + 2 * n!1) /= 0
[2]   (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1))
        =
        factorial(2 + 2 * n!1) *
         ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1))
         * (1 - sq(z!1)) ^ (3 + 2 * n!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.1.2.

atanh_series.1.1.1.1.1.1.3 (TCC):   

[-1]  abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[-2]  atanhND(1 + n!1)(c!1) > 0
[-3]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
{1}   (2 * (1 - sq(z!1)) ^ (3 + 2 * n!1)) /= 0
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.1.3.


This completes the proof of atanh_series.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.2 :  

[-1]  atanhND(1 + n!1)(c!1) > 0
[-2]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
{1}   abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  atanhND(1 + n!1)(c!1) > 0
[-2]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   abs(atanhND(1 + n!1)(c!1)) <= atanhND(1 + n!1)(z!1)

Rerunning step: (expand "abs" 1)
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  atanhND(1 + n!1)(c!1) > 0
[-2]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
{1}   IF atanhND(1 + n!1)(c!1) < 0 THEN -atanhND(1 + n!1)(c!1)
      ELSE atanhND(1 + n!1)(c!1)
      ENDIF
       <= atanhND(1 + n!1)(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  atanhND(1 + n!1)(c!1) > 0
{-2}  6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
       4 * ((1 - sq(z!1)) ^ (3 + 2 * n!1) * n!1)
       > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
       4 * ((1 - sq(z!1)) ^ (3 + 2 * n!1) * n!1)
       > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) <= atanhND(1 + n!1)(z!1)

Rerunning step: (expand "atanhND")
Expanding the definition of atanhND,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   atanhN(1 + n!1)(c!1) / atanhD(1 + n!1)(c!1) <=
       atanhN(1 + n!1)(z!1) / atanhD(1 + n!1)(z!1)

Rerunning step: (expand "atanhN")
Expanding the definition of atanhN,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) / atanhD(1 + n!1)(c!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) / atanhD(1 + n!1)(z!1)

Rerunning step: (expand "atanhD")
Expanding the definition of atanhD,
this simplifies to: 
atanh_series.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "1-sq(c!1)>0")
Case splitting on 
   1 - sq(c!1) > 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1 :  

{-1}  1 - sq(c!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)

Rerunning step: (lemma "expt_pos" ("px" "1-sq(c!1)" "i" "3+2*n!1"))
Applying expt_pos where 
  px gets 1 - sq(c!1),
  i gets 3 + 2 * n!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1 :  

{-1}  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  1 - sq(c!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)

Rerunning step: (rewrite "div_mult_pos_le1" 1)
Found matching substitution:
x gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1),
py: posreal gets (1 - sq(c!1)) ^ (3 + 2 * n!1),
z: real gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1),
Rewriting using div_mult_pos_le1, matching in 1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1 :  

[-1]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  1 - sq(c!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) <=
       (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
         (1 - sq(z!1)) ^ (3 + 2 * n!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (lemma "div_mult_pos_le2"
                 ("z"
                  "polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1)*(1 - sq(c!1)) ^ (3 + 2 * n!1)"
                  "py" "(1 - sq(z!1)) ^ (3 + 2 * n!1)" "x"
                  "polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1)"))
Ignoring 1 repeated TCCs.
Applying div_mult_pos_le2 where 
  z gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
          (1 - sq(c!1)) ^ (3 + 2 * n!1),
  py gets (1 - sq(z!1)) ^ (3 + 2 * n!1),
  x gets polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1 :  

{-1}  polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)
        / (1 - sq(z!1)) ^ (3 + 2 * n!1)
       IFF
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        <=
        polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
         (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-2]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-3]  1 - sq(c!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) <=
       (polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
         (1 - sq(z!1)) ^ (3 + 2 * n!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1 :  

[-1]  polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)
        / (1 - sq(z!1)) ^ (3 + 2 * n!1)
       IFF
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
        (1 - sq(z!1)) ^ (3 + 2 * n!1)
        <=
        polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
         (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-2]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-3]  1 - sq(c!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1 :  

[-1]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  1 - sq(c!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (lemma "even_polynomial"
                 ("a" "atanhF(1 + n!1)" "n" "1 + n!1"))
Applying even_polynomial where 
  a gets atanhF(1 + n!1),
  n gets 1 + n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1 :  

{-1}  FORALL (x: real):
        even_fs?(atanhF(1 + n!1)) IMPLIES
         polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(x) =
          polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                    (x ^ 2)
[-2]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-3]  1 - sq(c!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "even_fs?(atanhF(1 + n!1))")
Case splitting on 
   even_fs?(atanhF(1 + n!1)), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

{-1}  even_fs?(atanhF(1 + n!1))
[-2]  FORALL (x: real):
        even_fs?(atanhF(1 + n!1)) IMPLIES
         polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(x) =
          polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                    (x ^ 2)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  even_fs?(atanhF(1 + n!1))
{-2}  FORALL (x: real):
        polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(x) =
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(x ^ 2)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst-cp - "c!1")
Instantiating (with copying) the top quantifier in - with the terms:
c!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  even_fs?(atanhF(1 + n!1))
[-2]  FORALL (x: real):
        polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(x) =
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(x ^ 2)
{-3}  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
[-4]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-5]  1 - sq(c!1) > 0
[-6]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst - "z!1")
Instantiating the top quantifier in - with the terms: 
 z!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  even_fs?(atanhF(1 + n!1))
{-2}  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(z!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(z!1 ^ 2)
[-3]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
[-4]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-5]  1 - sq(c!1) > 0
[-6]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -2)
Replacing using formula -2,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  even_fs?(atanhF(1 + n!1))
[-2]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(z!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(z!1 ^ 2)
[-3]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
[-4]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-5]  1 - sq(c!1) > 0
[-6]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -3)
Replacing using formula -3,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  even_fs?(atanhF(1 + n!1))
[-2]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(z!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(z!1 ^ 2)
[-3]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
[-4]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-5]  1 - sq(c!1) > 0
[-6]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide -1 -2 -3)
Hiding formulas:  -1, -2, -3,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1 :  

[-1]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  1 - sq(c!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "FORALL (x:real): x^2 = sq(x)")
Case splitting on 
   FORALL (x: real): x ^ 2 = sq(x), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1 :  

{-1}  FORALL (x: real): x ^ 2 = sq(x)
[-2]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-3]  1 - sq(c!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst-cp - "c!1")
Instantiating (with copying) the top quantifier in - with the terms:
c!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1 :  

[-1]  FORALL (x: real): x ^ 2 = sq(x)
{-2}  c!1 ^ 2 = sq(c!1)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst - "z!1")
Instantiating the top quantifier in - with the terms: 
 z!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1 :  

{-1}  z!1 ^ 2 = sq(z!1)
[-2]  c!1 ^ 2 = sq(c!1)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1 :  

[-1]  z!1 ^ 2 = sq(z!1)
[-2]  c!1 ^ 2 = sq(c!1)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (replace -2)
Replacing using formula -2,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1 :  

[-1]  z!1 ^ 2 = sq(z!1)
[-2]  c!1 ^ 2 = sq(c!1)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "sq(c!1)<=sq(z!1)")
Case splitting on 
   sq(c!1) <= sq(z!1), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1 :  

{-1}  sq(c!1) <= sq(z!1)
[-2]  z!1 ^ 2 = sq(z!1)
[-3]  c!1 ^ 2 = sq(c!1)
[-4]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-5]  1 - sq(c!1) > 0
[-6]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-7]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-8]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (lemma "both_sides_expt_pos_le"
                 ("px" "1-sq(z!1)" "py" "1-sq(c!1)" "pm" "3+2*n!1"))
Ignoring 2 repeated TCCs.
Applying both_sides_expt_pos_le where 
  px gets 1 - sq(z!1),
  py gets 1 - sq(c!1),
  pm gets 3 + 2 * n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1 :  

{-1}  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1) IFF
       1 - sq(z!1) <= 1 - sq(c!1)
[-2]  sq(c!1) <= sq(z!1)
[-3]  z!1 ^ 2 = sq(z!1)
[-4]  c!1 ^ 2 = sq(c!1)
[-5]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-6]  1 - sq(c!1) > 0
[-7]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-8]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-9]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1 :  

{-1}  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-2]  sq(c!1) <= sq(z!1)
[-3]  z!1 ^ 2 = sq(z!1)
[-4]  c!1 ^ 2 = sq(c!1)
[-5]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-6]  1 - sq(c!1) > 0
[-7]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-8]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-9]  1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "FORALL (n:nat): polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) > 0")
Case splitting on 
   FORALL (n: nat):
     polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) >
      0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1 :  

{-1}  FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-3]  sq(c!1) <= sq(z!1)
[-4]  z!1 ^ 2 = sq(z!1)
[-5]  c!1 ^ 2 = sq(c!1)
[-6]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-7]  1 - sq(c!1) > 0
[-8]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-9]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-10] 1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst - "1+n!1")
Instantiating the top quantifier in - with the terms: 
 1+n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1 :  

{-1}  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-3]  sq(c!1) <= sq(z!1)
[-4]  z!1 ^ 2 = sq(z!1)
[-5]  c!1 ^ 2 = sq(c!1)
[-6]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-7]  1 - sq(c!1) > 0
[-8]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-9]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-10] 1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (case "FORALL (n:nat): polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(z!1))")
Case splitting on 
   FORALL (n: nat):
     polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) <=
      polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(z!1)), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1 :  

{-1}  FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) <=
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(z!1))
[-2]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-4]  sq(c!1) <= sq(z!1)
[-5]  z!1 ^ 2 = sq(z!1)
[-6]  c!1 ^ 2 = sq(c!1)
[-7]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-8]  1 - sq(c!1) > 0
[-9]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-10] abs(z!1 ^ (3 + 2 * n!1)) < 1
[-11] 1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (inst - "1+n!1")
Instantiating the top quantifier in - with the terms: 
 1+n!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1 :  

{-1}  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(z!1))
[-2]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-4]  sq(c!1) <= sq(z!1)
[-5]  z!1 ^ 2 = sq(z!1)
[-6]  c!1 ^ 2 = sq(c!1)
[-7]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-8]  1 - sq(c!1) > 0
[-9]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-10] abs(z!1 ^ (3 + 2 * n!1)) < 1
[-11] 1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (lemma "le_times_le_pos"
                 ("nnx"
                  "polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))"
                  "nnz" "(1 - sq(z!1)) ^ (3 + 2 * n!1)" "y"
                  "polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(z!1))"
                  "w" "(1 - sq(c!1)) ^ (3 + 2 * n!1)"))
Applying le_times_le_pos where 
  nnx gets polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                     (sq(c!1)),
  nnz gets (1 - sq(z!1)) ^ (3 + 2 * n!1),
  y gets polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                   (sq(z!1)),
  w gets (1 - sq(c!1)) ^ (3 + 2 * n!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1.1 :  

{-1}  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
       AND (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
       IMPLIES
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(c!1))
        * (1 - sq(z!1)) ^ (3 + 2 * n!1)
        <=
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                  (sq(z!1))
         * (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-2]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(z!1))
[-3]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-5]  sq(c!1) <= sq(z!1)
[-6]  z!1 ^ 2 = sq(z!1)
[-7]  c!1 ^ 2 = sq(c!1)
[-8]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-9]  1 - sq(c!1) > 0
[-10] (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-11] abs(z!1 ^ (3 + 2 * n!1)) < 1
[-12] 1 - sq(z!1) > 0
  |-------
[1]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1.2 (TCC):   

[-1]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(z!1))
[-2]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-4]  sq(c!1) <= sq(z!1)
[-5]  z!1 ^ 2 = sq(z!1)
[-6]  c!1 ^ 2 = sq(c!1)
[-7]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-8]  1 - sq(c!1) > 0
[-9]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-10] abs(z!1 ^ (3 + 2 * n!1)) < 1
[-11] 1 - sq(z!1) > 0
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       >= 0
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2 :  

[-1]  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-3]  sq(c!1) <= sq(z!1)
[-4]  z!1 ^ 2 = sq(z!1)
[-5]  c!1 ^ 2 = sq(c!1)
[-6]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-7]  1 - sq(c!1) > 0
[-8]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-9]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-10] 1 - sq(z!1) > 0
  |-------
{1}   FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) <=
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(z!1))
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but (1 -3))
Keeping (1 -3) and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2 :  

[-1]  sq(c!1) <= sq(z!1)
  |-------
[1]   FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) <=
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(z!1))

Rerunning step: (induct "n")
Inducting on n on formula 1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.1 :  

[-1]  sq(c!1) <= sq(z!1)
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 0)(sq(c!1)) <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 0)(sq(z!1))

Rerunning step: (rewrite "polynomial_n0")
Found matching substitution:
a: sequence[real] gets LAMBDA (i: nat): atanhF(1 + n!1)(2 * i),
Rewriting using polynomial_n0, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.1 :  

[-1]  sq(c!1) <= sq(z!1)
  |-------
{1}   (LAMBDA (x: real): atanhF(1 + n!1)(0))(sq(c!1)) <=
       (LAMBDA (x: real): atanhF(1 + n!1)(0))(sq(z!1))

Rerunning step: (simplify 1)
Simplifying with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.1 :  

[-1]  sq(c!1) <= sq(z!1)
  |-------
{1}   atanhF(1 + n!1)(0) <= atanhF(1 + n!1)(0)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

[-1]  sq(c!1) <= sq(z!1)
  |-------
{1}   FORALL j:
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j)(sq(c!1)) <=
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j)(sq(z!1))
         IMPLIES
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j + 1)
                   (sq(c!1))
          <=
          polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j + 1)
                    (sq(z!1))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

{-1}  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1)(sq(c!1)) <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1)(sq(z!1))
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1 + 1)(sq(c!1))
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1 + 1)(sq(z!1))

Rerunning step: (expand "polynomial")
Expanding the definition of polynomial,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

{-1}  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       <=
       sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   sigma(0, 1 + j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       <=
       sigma(0, 1 + j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))

Rerunning step: (expand "sigma" 1)
Expanding the definition of sigma,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

[-1]  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       <=
       sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1)
       <=
       sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))
        + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (name-replace "K100" "sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))")
Using K100 to name and replace sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

{-1}  K100 <=
       sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))
        + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (name-replace "K101" "sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF))")
Using K101 to name and replace sigma(0, j!1,
             LAMBDA (i_1: nat):
               atanhF(1 + n!1)(2 * i_1) *
                (IF i_1 = 0 THEN 1 ELSE sq(z!1) ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2 :  

{-1}  K100 <= K101
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (case-replace "sq(c!1)=0")
Assuming and applying sq(c!1)=0,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

{-1}  sq(c!1) = 0
[-2]  K100 <= K101
{-3}  0 <= sq(z!1)
  |-------
{1}   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * 0 ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (expand "^" 1 1)
Expanding the definition of ^,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

[-1]  sq(c!1) = 0
[-2]  K100 <= K101
[-3]  0 <= sq(z!1)
  |-------
{1}   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * expt(0, 1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (expand "expt" 1 1)
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

[-1]  sq(c!1) = 0
[-2]  K100 <= K101
[-3]  0 <= sq(z!1)
  |-------
{1}   K100 <= K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (lemma "expt_pos" ("px" "sq(z!1)" "i" "1+j!1"))
Applying expt_pos where 
  px gets sq(z!1),
  i gets 1 + j!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

{-1}  sq(z!1) ^ (1 + j!1) > 0
[-2]  sq(c!1) = 0
[-3]  K100 <= K101
[-4]  0 <= sq(z!1)
  |-------
[1]   K100 <= K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

[-1]  sq(z!1) ^ (1 + j!1) > 0
[-2]  sq(c!1) = 0
[-3]  K100 <= K101
[-4]  0 <= sq(z!1)
  |-------
{1}   K100 <=
       K101 +
        IF 2 + 2 * j!1 > 2 + 2 * n!1 OR odd?(2 + 2 * j!1) THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
        ENDIF
         * sq(z!1) ^ (1 + j!1)

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1 :  

[-1]  sq(z!1) ^ (1 + j!1) > 0
[-2]  sq(c!1) = 0
[-3]  K100 <= K101
[-4]  0 <= sq(z!1)
  |-------
{1}   K100 <=
       K101 +
        IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
        ENDIF
         * sq(z!1) ^ (1 + j!1)

Rerunning step: (case "j!1>n!1")
Case splitting on 
   j!1 > n!1, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.1 :  

{-1}  j!1 > n!1
[-2]  sq(z!1) ^ (1 + j!1) > 0
[-3]  sq(c!1) = 0
[-4]  K100 <= K101
[-5]  0 <= sq(z!1)
  |-------
[1]   K100 <=
       K101 +
        IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
        ENDIF
         * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.2 :  

[-1]  sq(z!1) ^ (1 + j!1) > 0
[-2]  sq(c!1) = 0
[-3]  K100 <= K101
[-4]  0 <= sq(z!1)
  |-------
{1}   j!1 > n!1
[2]   K100 <=
       K101 +
        IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
        ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
        ENDIF
         * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.2 :  

[-1]  sq(z!1) ^ (1 + j!1) > 0
[-2]  sq(c!1) = 0
[-3]  K100 <= K101
[-4]  0 <= sq(z!1)
  |-------
[1]   j!1 > n!1
{2}   K100 <=
       K101 +
        factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
         sq(z!1) ^ (1 + j!1)

Rerunning step: (lemma "posreal_times_posreal_is_posreal"
                 ("px"
                  "factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)"
                  "py" "sq(z!1) ^ (1 + j!1)"))
Applying posreal_times_posreal_is_posreal where 
  px gets factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1),
  py gets sq(z!1) ^ (1 + j!1),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.2 :  

{-1}  factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
       sq(z!1) ^ (1 + j!1)
       > 0
[-2]  sq(z!1) ^ (1 + j!1) > 0
[-3]  sq(c!1) = 0
[-4]  K100 <= K101
[-5]  0 <= sq(z!1)
  |-------
[1]   j!1 > n!1
[2]   K100 <=
       K101 +
        factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
         sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2 :  

[-1]  K100 <= K101
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (lemma "both_sides_expt_pos_le"
                 ("px" "sq(c!1)" "py" "sq(z!1)" "pm" "1+j!1"))
Applying both_sides_expt_pos_le where 
  px gets sq(c!1),
  py gets sq(z!1),
  pm gets 1 + j!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1 :  

{-1}  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-2]  K100 <= K101
[-3]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (case "0 <= atanhF(1 + n!1)(2 + 2 * j!1)")
Case splitting on 
   0 <= atanhF(1 + n!1)(2 + 2 * j!1), 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1 :  

{-1}  0 <= atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (expand "<=" -1)
Expanding the definition of <=,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1 :  

{-1}  0 < atanhF(1 + n!1)(2 + 2 * j!1) OR 0 = atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1 :  

{-1}  0 < atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (lemma "both_sides_times_pos_le1"
                 ("x" "sq(c!1) ^ (1 + j!1)" "y" "sq(z!1) ^ (1 + j!1)"
                  "pz" "atanhF(1 + n!1)(2 + 2 * j!1)"))
Applying both_sides_times_pos_le1 where 
  x gets sq(c!1) ^ (1 + j!1),
  y gets sq(z!1) ^ (1 + j!1),
  pz gets atanhF(1 + n!1)(2 + 2 * j!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1.1 :  

{-1}  sq(c!1) ^ (1 + j!1) * atanhF(1 + n!1)(2 + 2 * j!1) <=
       sq(z!1) ^ (1 + j!1) * atanhF(1 + n!1)(2 + 2 * j!1)
       IFF sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1)
[-2]  0 < atanhF(1 + n!1)(2 + 2 * j!1)
[-3]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-4]  K100 <= K101
[-5]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1.2 (TCC):   

[-1]  0 < atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
{1}   atanhF(1 + n!1)(2 + 2 * j!1) >= 0 AND atanhF(1 + n!1)(2 + 2 * j!1) > 0
[2]   sq(c!1) = 0
[3]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.2 :  

{-1}  0 = atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
[2]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (replace -1 * rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.2 :  

[-1]  0 = atanhF(1 + n!1)(2 + 2 * j!1)
[-2]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-3]  K100 <= K101
[-4]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) = 0
{2}   K100 + 0 * sq(c!1) ^ (1 + j!1) <= K101 + 0 * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2 :  

[-1]  sq(c!1) ^ (1 + j!1) <= sq(z!1) ^ (1 + j!1) IFF sq(c!1) <= sq(z!1)
[-2]  K100 <= K101
[-3]  sq(c!1) <= sq(z!1)
  |-------
{1}   0 <= atanhF(1 + n!1)(2 + 2 * j!1)
[2]   sq(c!1) = 0
[3]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2 :  

  |-------
[1]   0 <= atanhF(1 + n!1)(2 + 2 * j!1)

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2 :  

  |-------
{1}   0 <=
       IF 2 + 2 * j!1 > 2 + 2 * n!1 OR odd?(2 + 2 * j!1) THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2 :  

  |-------
{1}   0 <=
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF

Rerunning step: (case "j!1>n!1")
Case splitting on 
   j!1 > n!1, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2.1 :  

{-1}  j!1 > n!1
  |-------
[1]   0 <=
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2.2 :  

  |-------
{1}   j!1 > n!1
[2]   0 <=
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.2 (TCC):   

[-1]  K100 <= K101
[-2]  sq(c!1) <= sq(z!1)
  |-------
{1}   sq(c!1) > 0
[2]   sq(c!1) = 0
[3]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (typepred "sq(c!1)")
Adding type constraints for  sq(c!1),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.2 :  

{-1}  sq(c!1) >= 0
[-2]  K100 <= K101
[-3]  sq(c!1) <= sq(z!1)
  |-------
[1]   sq(c!1) > 0
[2]   sq(c!1) = 0
[3]   K100 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) <=
       K101 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(z!1) ^ (1 + j!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) <= (1 - sq(c!1)) ^ (3 + 2 * n!1)
[-2]  sq(c!1) <= sq(z!1)
[-3]  z!1 ^ 2 = sq(z!1)
[-4]  c!1 ^ 2 = sq(c!1)
[-5]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-6]  1 - sq(c!1) > 0
[-7]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-8]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-9]  1 - sq(z!1) > 0
  |-------
{1}   FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) > 0
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2 :  

  |-------
[1]   FORALL (n: nat):
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), n)(sq(c!1)) > 0

Rerunning step: (induct "n")
Inducting on n on formula 1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 0)(sq(c!1)) > 0

Rerunning step: (rewrite "polynomial_n0")
Found matching substitution:
a: sequence[real] gets LAMBDA (i: nat): atanhF(1 + n!1)(2 * i),
Rewriting using polynomial_n0, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

  |-------
{1}   (LAMBDA (x: real): atanhF(1 + n!1)(0))(sq(c!1)) > 0

Rerunning step: (simplify)
Simplifying with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

  |-------
{1}   atanhF(1 + n!1)(0) > 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

  |-------
{1}   IF odd?(0) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0)
      ENDIF
       > 0

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1 :  

  |-------
{1}   factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

  |-------
{1}   FORALL j:
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j)(sq(c!1)) > 0
         IMPLIES
         polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j + 1)
                   (sq(c!1))
          > 0

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1)(sq(c!1)) > 0
  |-------
{1}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), j!1 + 1)(sq(c!1))
       > 0

Rerunning step: (expand "polynomial")
Expanding the definition of polynomial,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       > 0
  |-------
{1}   sigma(0, 1 + j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       > 0

Rerunning step: (expand "sigma" 1)
Expanding the definition of sigma,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

[-1]  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       > 0
  |-------
{1}   sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))
       + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (name-replace "K103" "sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF))")
Using K103 to name and replace sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE sq(c!1) ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  K103 > 0
  |-------
{1}   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (typepred "sq(c!1)")
Adding type constraints for  sq(c!1),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  sq(c!1) >= 0
[-2]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (expand ">=" -1)
Expanding the definition of >=,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  0 <= sq(c!1)
[-2]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (expand "<=" -1)
Expanding the definition of <=,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2 :  

{-1}  0 < sq(c!1) OR 0 = sq(c!1)
[-2]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1 :  

{-1}  0 < sq(c!1)
[-2]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (lemma "expt_pos" ("px" "sq(c!1)" "i" "1+j!1"))
Applying expt_pos where 
  px gets sq(c!1),
  i gets 1 + j!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1 :  

{-1}  sq(c!1) ^ (1 + j!1) > 0
[-2]  0 < sq(c!1)
[-3]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1 :  

[-1]  sq(c!1) ^ (1 + j!1) > 0
[-2]  0 < sq(c!1)
[-3]  K103 > 0
  |-------
{1}   K103 +
       IF 2 + 2 * j!1 > 2 + 2 * n!1 OR odd?(2 + 2 * j!1) THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF
        * sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1 :  

[-1]  sq(c!1) ^ (1 + j!1) > 0
[-2]  0 < sq(c!1)
[-3]  K103 > 0
  |-------
{1}   K103 +
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF
        * sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (case "j!1>n!1")
Case splitting on 
   j!1 > n!1, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.1 :  

{-1}  j!1 > n!1
[-2]  sq(c!1) ^ (1 + j!1) > 0
[-3]  0 < sq(c!1)
[-4]  K103 > 0
  |-------
[1]   K103 +
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF
        * sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.2 :  

[-1]  sq(c!1) ^ (1 + j!1) > 0
[-2]  0 < sq(c!1)
[-3]  K103 > 0
  |-------
{1}   j!1 > n!1
[2]   K103 +
       IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
       ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
       ENDIF
        * sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.2 :  

[-1]  sq(c!1) ^ (1 + j!1) > 0
[-2]  0 < sq(c!1)
[-3]  K103 > 0
  |-------
[1]   j!1 > n!1
{2}   K103 +
       factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
        sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (lemma "posreal_times_posreal_is_posreal"
                 ("px"
                  "factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)"
                  "py" "sq(c!1) ^ (1 + j!1)"))
Applying posreal_times_posreal_is_posreal where 
  px gets factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1),
  py gets sq(c!1) ^ (1 + j!1),
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.2 :  

{-1}  factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
       sq(c!1) ^ (1 + j!1)
       > 0
[-2]  sq(c!1) ^ (1 + j!1) > 0
[-3]  0 < sq(c!1)
[-4]  K103 > 0
  |-------
[1]   j!1 > n!1
[2]   K103 +
       factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1) *
        sq(c!1) ^ (1 + j!1)
       > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.2 (TCC):   

[-1]  0 < sq(c!1)
[-2]  K103 > 0
  |-------
{1}   sq(c!1) > 0
[2]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

{-1}  0 = sq(c!1)
[-2]  K103 > 0
  |-------
[1]   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * sq(c!1) ^ (1 + j!1) > 0

Rerunning step: (replace -1 * rl)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

[-1]  0 = sq(c!1)
[-2]  K103 > 0
  |-------
{1}   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * 0 ^ (1 + j!1) > 0

Rerunning step: (expand "^" 1)
Expanding the definition of ^,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

[-1]  0 = sq(c!1)
[-2]  K103 > 0
  |-------
{1}   K103 + atanhF(1 + n!1)(2 + 2 * j!1) * expt(0, 1 + j!1) > 0

Rerunning step: (expand "expt" 1)
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.2 :  

[-1]  0 = sq(c!1)
[-2]  K103 > 0
  |-------
{1}   K103 > 0

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.2 :  

[-1]  z!1 ^ 2 = sq(z!1)
[-2]  c!1 ^ 2 = sq(c!1)
[-3]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-4]  1 - sq(c!1) > 0
[-5]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-6]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-7]  1 - sq(z!1) > 0
  |-------
{1}   sq(c!1) <= sq(z!1)
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(sq(c!1))
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (sq(z!1))
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2 :  

  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (typepred "c!1")
Adding type constraints for  c!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2 :  

{-1}  -1 < c!1
{-2}  c!1 < 1
{-3}  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
{-4}  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
{-5}  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (lemma "trichotomy" ("x" "z!1"))
Applying trichotomy where 
  x gets z!1,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2 :  

{-1}  z!1 > 0 OR z!1 = 0 OR 0 > z!1
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.1 :  

{-1}  z!1 > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.1 :  

[-1]  z!1 > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
{-4}  0 < c!1 AND c!1 < z!1
{-5}  (FALSE IMPLIES z!1 < c!1 AND c!1 < 0)
{-6}  (FALSE IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (flatten -4)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.1 :  

[-1]  z!1 > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
{-4}  0 < c!1
{-5}  c!1 < z!1
[-6]  (FALSE IMPLIES z!1 < c!1 AND c!1 < 0)
[-7]  (FALSE IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (lemma "sq_lt" ("nna" "c!1" "nnb" "z!1"))
Applying sq_lt where 
  nna gets c!1,
  nnb gets z!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.1.1 :  

{-1}  sq(c!1) < sq(z!1) IFF c!1 < z!1
[-2]  z!1 > 0
[-3]  -1 < c!1
[-4]  c!1 < 1
[-5]  0 < c!1
[-6]  c!1 < z!1
[-7]  (FALSE IMPLIES z!1 < c!1 AND c!1 < 0)
[-8]  (FALSE IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.2.1.2 (TCC):   

[-1]  z!1 > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  0 < c!1
[-5]  c!1 < z!1
[-6]  (FALSE IMPLIES z!1 < c!1 AND c!1 < 0)
[-7]  (FALSE IMPLIES c!1 = 0)
  |-------
{1}   c!1 >= 0
[2]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.2.2 :  

{-1}  z!1 = 0
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.2.

atanh_series.1.1.1.1.1.2.1.1.1.1.2.3 :  

{-1}  0 > z!1
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (lemma "sq_lt" ("nna" "-c!1" "nnb" "-z!1"))
Applying sq_lt where 
  nna gets -c!1,
  nnb gets -z!1,
this yields  3 subgoals: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.1 :  

{-1}  sq(-c!1) < sq(-z!1) IFF -c!1 < -z!1
[-2]  0 > z!1
[-3]  -1 < c!1
[-4]  c!1 < 1
[-5]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-6]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-7]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (rewrite "sq_neg")
Found matching substitution:
a: real gets c!1,
Rewriting using sq_neg, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.1 :  

{-1}  sq(c!1) < sq(-z!1) IFF -c!1 < -z!1
[-2]  0 > z!1
[-3]  -1 < c!1
[-4]  c!1 < 1
[-5]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-6]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-7]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (rewrite "sq_neg")
Found matching substitution:
a: real gets z!1,
Rewriting using sq_neg, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.1 :  

{-1}  sq(c!1) < sq(z!1) IFF -c!1 < -z!1
[-2]  0 > z!1
[-3]  -1 < c!1
[-4]  c!1 < 1
[-5]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-6]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-7]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
[1]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.1.

atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.2 (TCC):   

[-1]  0 > z!1
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
{1}   -z!1 >= 0
[2]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.2.

atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.3 (TCC):   

[-1]  0 > z!1
[-2]  -1 < c!1
[-3]  c!1 < 1
[-4]  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
[-5]  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
[-6]  (0 = z!1 IMPLIES c!1 = 0)
  |-------
{1}   -c!1 >= 0
[2]   sq(c!1) <= sq(z!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.3.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.3.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.1.2 :  

[-1]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  1 - sq(c!1) > 0
[-3]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-4]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-5]  1 - sq(z!1) > 0
  |-------
{1}   FORALL (x: real): x ^ 2 = sq(x)
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       * (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                 (z!1 ^ 2)
        * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.1.2 :  

  |-------
[1]   FORALL (x: real): x ^ 2 = sq(x)

Rerunning step: (grind)
expt rewrites expt(x, 0)
  to 1
expt rewrites expt(x, 1)
  to x
expt rewrites expt(x, 2)
  to x * x
^ rewrites x ^ 2
  to x * x
sq rewrites sq(x)
  to x * x
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.1.

atanh_series.1.1.1.1.1.2.1.1.2 :  

[-1]  FORALL (x: real):
        even_fs?(atanhF(1 + n!1)) IMPLIES
         polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(x) =
          polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                    (x ^ 2)
[-2]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-3]  1 - sq(c!1) > 0
[-4]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-5]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-6]  1 - sq(z!1) > 0
  |-------
{1}   even_fs?(atanhF(1 + n!1))
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) *
       (1 - sq(z!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) *
        (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.2 :  

  |-------
[1]   even_fs?(atanhF(1 + n!1))

Rerunning step: (expand "even_fs?")
Expanding the definition of even_fs?,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.2 :  

  |-------
{1}   FORALL (i: nat): odd?(i) => atanhF(1 + n!1)(i) = 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.2 :  

  |-------
{1}   FORALL (i: nat):
        odd?(i) =>
         IF i > 2 + 2 * n!1 OR odd?(i) THEN 0
         ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, i)
         ENDIF
          = 0

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.1.2.1.1.2 :  

{-1}  odd?(i!1)
  |-------
{1}   IF i!1 > 2 + 2 * n!1 OR odd?(i!1) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, i!1)
      ENDIF
       = 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.1.

atanh_series.1.1.1.1.1.2.1.2 (TCC):   

[-1]  1 - sq(c!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.1.

atanh_series.1.1.1.1.1.2.2 :  

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   1 - sq(c!1) > 0
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       <=
       polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(z!1) /
        (1 - sq(z!1)) ^ (3 + 2 * n!1)

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.2 :  

  |-------
[1]   1 - sq(c!1) > 0

Rerunning step: (case "c!1>=0")
Case splitting on 
   c!1 >= 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.2.1 :  

{-1}  c!1 >= 0
  |-------
[1]   1 - sq(c!1) > 0

Rerunning step: (lemma "sq_gt" ("nna" "1" "nnb" "c!1"))
Applying sq_gt where 
  nna gets 1,
  nnb gets c!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.2.1.1 :  

{-1}  sq(1) > sq(c!1) IFF 1 > c!1
[-2]  c!1 >= 0
  |-------
[1]   1 - sq(c!1) > 0

Rerunning step: (rewrite "sq_1")
Found matching substitution:
Rewriting using sq_1, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.2.1.1 :  

{-1}  1 > sq(c!1) IFF 1 > c!1
[-2]  c!1 >= 0
  |-------
[1]   1 - sq(c!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.2.1.1.

atanh_series.1.1.1.1.1.2.2.1.2 (TCC):   

[-1]  c!1 >= 0
  |-------
{1}   c!1 >= 0
[2]   1 - sq(c!1) > 0

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.1.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.1.2.2.1.

atanh_series.1.1.1.1.1.2.2.2 :  

  |-------
{1}   c!1 >= 0
[2]   1 - sq(c!1) > 0

Rerunning step: (lemma "sq_gt" ("nna" "1" "nnb" "-c!1"))
Applying sq_gt where 
  nna gets 1,
  nnb gets -c!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.1.2.2.2.1 :  

{-1}  sq(1) > sq(-c!1) IFF 1 > -c!1
  |-------
[1]   c!1 >= 0
[2]   1 - sq(c!1) > 0

Rerunning step: (rewrite "sq_1")
Found matching substitution:
Rewriting using sq_1, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.2.2.1 :  

{-1}  1 > sq(-c!1) IFF 1 > -c!1
  |-------
[1]   c!1 >= 0
[2]   1 - sq(c!1) > 0

Rerunning step: (rewrite "sq_neg")
Found matching substitution:
a: real gets c!1,
Rewriting using sq_neg, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.1.2.2.2.1 :  

{-1}  1 > sq(c!1) IFF 1 > -c!1
  |-------
[1]   c!1 >= 0
[2]   1 - sq(c!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.2.2.1.

atanh_series.1.1.1.1.1.2.2.2.2 (TCC):   

  |-------
{1}   -c!1 >= 0
[2]   c!1 >= 0
[3]   1 - sq(c!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.1.2.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.1.

atanh_series.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   atanhND(1 + n!1)(c!1) > 0
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
[1]   atanhND(1 + n!1)(c!1) > 0

Rerunning step: (expand "atanhND")
Expanding the definition of atanhND,
this simplifies to: 
atanh_series.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   atanhN(1 + n!1)(c!1) / atanhD(1 + n!1)(c!1) > 0

Rerunning step: (expand "atanhN")
Expanding the definition of atanhN,
this simplifies to: 
atanh_series.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) / atanhD(1 + n!1)(c!1)
       > 0

Rerunning step: (expand "atanhD")
Expanding the definition of atanhD,
this simplifies to: 
atanh_series.1.1.1.1.2 :  

[-1]  (6 + 4 * n!1) * (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-3]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-4]  1 - sq(z!1) > 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (hide -1 -2 -3 -4)
Hiding formulas:  -1, -2, -3, -4,
this simplifies to: 
atanh_series.1.1.1.1.2 :  

  |-------
[1]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (case-replace "c!1=0")
Assuming and applying c!1=0,
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.1 :  

{-1}  c!1 = 0
  |-------
{1}   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(0) /
       (1 - sq(0)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (rewrite "polynomial_x0")
Found matching substitution:
n: nat gets 2 + 2 * n!1,
a: sequence[real] gets atanhF(1 + n!1),
Rewriting using polynomial_x0, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   atanhF(1 + n!1)(0) / (1 - sq(0)) ^ (3 + 2 * n!1) > 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   IF odd?(0) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0)
      ENDIF
       / (1 - sq(0)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0) /
       (1 - sq(0)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (rewrite "C_0")
Found matching substitution:
n: nat gets 3 + 2 * n!1,
Rewriting using C_0, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   factorial(2 + 2 * n!1) * 1 / (1 - sq(0)) ^ (3 + 2 * n!1) > 0

Rerunning step: (assert)
sq_0 rewrites sq(0)
  to 0
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   factorial(2 + 2 * n!1) / 1 ^ (3 + 2 * n!1) > 0

Rerunning step: (cross-mult)

Multiplying both sides of selected formulas by LHS/RHS divisor(s),
this simplifies to: 
atanh_series.1.1.1.1.2.1 :  

[-1]  c!1 = 0
  |-------
{1}   factorial(2 + 2 * n!1) > 0 * 1 ^ (3 + 2 * n!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.1.

atanh_series.1.1.1.1.2.2 :  

  |-------
{1}   c!1 = 0
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (lemma "even_polynomial"
                 ("a" "atanhF(1 + n!1)" "n" "1 + n!1" "x" "c!1"))
Applying even_polynomial where 
  a gets atanhF(1 + n!1),
  n gets 1 + n!1,
  x gets c!1,
this simplifies to: 
atanh_series.1.1.1.1.2.2 :  

{-1}  even_fs?(atanhF(1 + n!1)) IMPLIES
       polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
        polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)
                  (c!1 ^ 2)
  |-------
[1]   c!1 = 0
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1 :  

{-1}  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
  |-------
[1]   c!1 = 0
[2]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (replace -1 2)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1 :  

[-1]  polynomial(atanhF(1 + n!1), 2 * (1 + n!1))(c!1) =
       polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
  |-------
[1]   c!1 = 0
{2}   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (hide -1)
Hiding formulas:  -1,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1 :  

  |-------
[1]   c!1 = 0
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (case "c!1^2>0")
Case splitting on 
   c!1 ^ 2 > 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1 :  

{-1}  c!1 ^ 2 > 0
  |-------
[1]   c!1 = 0
[2]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (expand "polynomial")
Expanding the definition of polynomial,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1 :  

[-1]  c!1 ^ 2 > 0
  |-------
[1]   c!1 = 0
{2}   sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE c!1 ^ 2 ^ i_1 ENDIF))
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (name-replace "KC" "c!1^2")
Using KC to name and replace c!1^2,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1 :  

{-1}  KC > 0
  |-------
[1]   c!1 = 0
{2}   sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (case "FORALL (n:nat): sigma(0, n,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0")
Free variables in expr i_1
Case splitting on 
   FORALL (n: nat):
     sigma(0, n,
           LAMBDA (i_1: nat):
             atanhF(1 + n!1)(2 * i_1) *
              (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
      > 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.1 :  

{-1}  FORALL (n: nat):
        sigma(0, n,
              LAMBDA (i_1: nat):
                atanhF(1 + n!1)(2 * i_1) *
                 (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
         > 0
[-2]  KC > 0
  |-------
[1]   c!1 = 0
[2]   sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (inst - "1+n!1")
Instantiating the top quantifier in - with the terms: 
 1+n!1,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1 :  

{-1}  sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0
[-2]  KC > 0
  |-------
[1]   c!1 = 0
[2]   sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (name-replace "SS" "sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))")
Using SS to name and replace sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1 :  

{-1}  SS > 0
[-2]  KC > 0
  |-------
[1]   c!1 = 0
{2}   SS / (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (case "(1 - sq(c!1)) ^ (3 + 2 * n!1) > 0")
Case splitting on 
   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.1.1 :  

{-1}  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  SS > 0
[-3]  KC > 0
  |-------
[1]   c!1 = 0
[2]   SS / (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (cross-mult 2)

Multiplying both sides of selected formulas by LHS/RHS divisor(s),
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.1 :  

[-1]  (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[-2]  SS > 0
[-3]  KC > 0
  |-------
[1]   c!1 = 0
{2}   SS > 0 * (1 - sq(c!1)) ^ (3 + 2 * n!1)

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.1.1.

atanh_series.1.1.1.1.2.2.1.1.1.2 :  

[-1]  SS > 0
[-2]  KC > 0
  |-------
{1}   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[2]   c!1 = 0
[3]   SS / (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (typepred "c!1")
Adding type constraints for  c!1,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2 :  

{-1}  -1 < c!1
{-2}  c!1 < 1
{-3}  (0 < z!1 IMPLIES 0 < c!1 AND c!1 < z!1)
{-4}  (z!1 < 0 IMPLIES z!1 < c!1 AND c!1 < 0)
{-5}  (0 = z!1 IMPLIES c!1 = 0)
[-6]  SS > 0
[-7]  KC > 0
  |-------
[1]   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0
[2]   c!1 = 0
[3]   SS / (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (hide-all-but (-1 -2 1))
Keeping (-1 -2 1) and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2 :  

[-1]  -1 < c!1
[-2]  c!1 < 1
  |-------
[1]   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (lemma "expt_pos_aux")
Applying expt_pos_aux 
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2 :  

{-1}  FORALL (n: nat, px: posreal): expt(px, n) > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
[1]   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (inst -1 "3+2*n!1" "1 - sq(c!1)")
Instantiating the top quantifier in -1 with the terms: 
 3+2*n!1, 1 - sq(c!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.1.2.1 :  

{-1}  expt(1 - sq(c!1), 3 + 2 * n!1) > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
[1]   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (expand "^")
Expanding the definition of ^,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2.1 :  

[-1]  expt(1 - sq(c!1), 3 + 2 * n!1) > 0
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
{1}   expt((1 - sq(c!1)), (3 + 2 * n!1)) > 0

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.1.2.1.

atanh_series.1.1.1.1.2.2.1.1.1.2.2 (TCC):   

[-1]  -1 < c!1
[-2]  c!1 < 1
  |-------
{1}   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0
[2]   (1 - sq(c!1)) ^ (3 + 2 * n!1) > 0

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2.2 :  

[-1]  -1 < c!1
[-2]  c!1 < 1
  |-------
[1]   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0

Rerunning step: (lemma "neg_pos_sq_lt")
Applying neg_pos_sq_lt 
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2.2 :  

{-1}  FORALL (a, b: real): (-b < a AND a < b) IMPLIES sq(a) < sq(b)
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
[1]   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0

Rerunning step: (inst?)
Found substitution:
a gets c!1,
b: real gets 1,
Using template: -b < a
Instantiating quantified variables,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2.2 :  

{-1}  (-1 < c!1 AND c!1 < 1) IMPLIES sq(c!1) < sq(1)
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
[1]   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0

Rerunning step: (rewrite "sq_1")
Found matching substitution:
Rewriting using sq_1, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.1.2.2 :  

{-1}  (-1 < c!1 AND c!1 < 1) IMPLIES sq(c!1) < 1
[-2]  -1 < c!1
[-3]  c!1 < 1
  |-------
[1]   1 - sq(c!1) >= 0 AND 1 - sq(c!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.1.

atanh_series.1.1.1.1.2.2.1.1.2 :  

[-1]  KC > 0
  |-------
{1}   FORALL (n: nat):
        sigma(0, n,
              LAMBDA (i_1: nat):
                atanhF(1 + n!1)(2 * i_1) *
                 (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
         > 0
[2]   c!1 = 0
[3]   sigma(0, 1 + n!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (hide 2 3)
Hiding formulas:  2, 3,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2 :  

[-1]  KC > 0
  |-------
[1]   FORALL (n: nat):
        sigma(0, n,
              LAMBDA (i_1: nat):
                atanhF(1 + n!1)(2 * i_1) *
                 (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
         > 0

Rerunning step: (induct "n")
Inducting on n on formula 1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.2.1 :  

[-1]  KC > 0
  |-------
{1}   sigma(0, 0,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0

Rerunning step: (expand "sigma" 1)
Expanding the definition of sigma,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.1 :  

[-1]  KC > 0
  |-------
{1}   atanhF(1 + n!1)(0) > 0

Rerunning step: (expand "atanhF" 1)
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.1 :  

[-1]  KC > 0
  |-------
{1}   IF odd?(0) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0)
      ENDIF
       > 0

Rerunning step: (expand "odd?" 1)
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.1 :  

[-1]  KC > 0
  |-------
{1}   factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 0) > 0

Rerunning step: (rewrite "C_0")
Found matching substitution:
n: nat gets 3 + 2 * n!1,
Rewriting using C_0, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.1 :  

[-1]  KC > 0
  |-------
{1}   factorial(2 + 2 * n!1) * 1 > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.1.

atanh_series.1.1.1.1.2.2.1.1.2.2 :  

[-1]  KC > 0
  |-------
{1}   FORALL j:
        sigma(0, j,
              LAMBDA (i_1: nat):
                atanhF(1 + n!1)(2 * i_1) *
                 (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
         > 0
         IMPLIES
         sigma(0, j + 1,
               LAMBDA (i_1: nat):
                 atanhF(1 + n!1)(2 * i_1) *
                  (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
          > 0

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2 :  

{-1}  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0
[-2]  KC > 0
  |-------
{1}   sigma(0, j!1 + 1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0

Rerunning step: (expand "sigma" 1)
Expanding the definition of sigma,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2 :  

[-1]  sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       > 0
[-2]  KC > 0
  |-------
{1}   sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))
       + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1)
       > 0

Rerunning step: (name-replace "K20" "sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF))")
Using K20 to name and replace sigma(0, j!1,
            LAMBDA (i_1: nat):
              atanhF(1 + n!1)(2 * i_1) *
               (IF i_1 = 0 THEN 1 ELSE KC ^ i_1 ENDIF)),
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2 :  

{-1}  K20 > 0
[-2]  KC > 0
  |-------
{1}   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (lemma "expt_pos" ("px" "KC" "i" "1+j!1"))
Applying expt_pos where 
  px gets KC,
  i gets 1 + j!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1 :  

{-1}  KC ^ (1 + j!1) > 0
[-2]  K20 > 0
[-3]  KC > 0
  |-------
[1]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (case "atanhF(1 + n!1)(2 + 2 * j!1) >=0")
Case splitting on 
   atanhF(1 + n!1)(2 + 2 * j!1) >= 0, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.1 :  

{-1}  atanhF(1 + n!1)(2 + 2 * j!1) >= 0
[-2]  KC ^ (1 + j!1) > 0
[-3]  K20 > 0
[-4]  KC > 0
  |-------
[1]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (lemma "both_sides_times_pos_ge1"
                 ("x" "atanhF(1 + n!1)(2 + 2 * j!1)" "y" "0" "pz"
                  "KC ^ (1 + j!1)"))
Applying both_sides_times_pos_ge1 where 
  x gets atanhF(1 + n!1)(2 + 2 * j!1),
  y gets 0,
  pz gets KC ^ (1 + j!1),
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.1.1 :  

{-1}  atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) >= 0 * KC ^ (1 + j!1)
       IFF atanhF(1 + n!1)(2 + 2 * j!1) >= 0
[-2]  atanhF(1 + n!1)(2 + 2 * j!1) >= 0
[-3]  KC ^ (1 + j!1) > 0
[-4]  K20 > 0
[-5]  KC > 0
  |-------
[1]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.1.1.

atanh_series.1.1.1.1.2.2.1.1.2.2.1.1.2 (TCC):   

[-1]  atanhF(1 + n!1)(2 + 2 * j!1) >= 0
[-2]  KC ^ (1 + j!1) > 0
[-3]  K20 > 0
[-4]  KC > 0
  |-------
{1}   KC ^ (1 + j!1) >= 0 AND KC ^ (1 + j!1) > 0
[2]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.1.

atanh_series.1.1.1.1.2.2.1.1.2.2.1.2 :  

[-1]  KC ^ (1 + j!1) > 0
[-2]  K20 > 0
[-3]  KC > 0
  |-------
{1}   atanhF(1 + n!1)(2 + 2 * j!1) >= 0
[2]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.2 :  

  |-------
[1]   atanhF(1 + n!1)(2 + 2 * j!1) >= 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.2 :  

  |-------
{1}   IF 2 + 2 * j!1 > 2 + 2 * n!1 OR odd?(2 + 2 * j!1) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
      ENDIF
       >= 0

Rerunning step: (expand "odd?")
Expanding the definition of odd?,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.2 :  

  |-------
{1}   IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
      ENDIF
       >= 0

Rerunning step: (case "j!1>n!1")
Case splitting on 
   j!1 > n!1, 
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.1.2.2.1.2.1 :  

{-1}  j!1 > n!1
  |-------
[1]   IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
      ENDIF
       >= 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.2.1.

atanh_series.1.1.1.1.2.2.1.1.2.2.1.2.2 :  

  |-------
{1}   j!1 > n!1
[2]   IF 2 + 2 * j!1 > 2 + 2 * n!1 THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, 2 + 2 * j!1)
      ENDIF
       >= 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.1.

atanh_series.1.1.1.1.2.2.1.1.2.2.2 (TCC):   

[-1]  K20 > 0
[-2]  KC > 0
  |-------
{1}   KC >= 0 AND KC > 0
[2]   K20 + atanhF(1 + n!1)(2 + 2 * j!1) * KC ^ (1 + j!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.1.

atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   c!1 ^ 2 > 0
[2]   c!1 = 0
[3]   polynomial(LAMBDA (i: nat): atanhF(1 + n!1)(2 * i), 1 + n!1)(c!1 ^ 2)
       / (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (hide 3)
Hiding formulas:  3,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
[1]   c!1 ^ 2 > 0
[2]   c!1 = 0

Rerunning step: (expand "^")
Expanding the definition of ^,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   expt(c!1, 2) > 0
[2]   c!1 = 0

Rerunning step: (expand "expt")
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   c!1 * expt(c!1, 1) > 0
[2]   c!1 = 0

Rerunning step: (expand "expt")
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   c!1 * (c!1 * expt(c!1, 0)) > 0
[2]   c!1 = 0

Rerunning step: (expand "expt")
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   c!1 * c!1 > 0
[2]   c!1 = 0

Rerunning step: (rewrite "sq_rew")
Found matching substitution:
a: real gets c!1,
Rewriting using sq_rew, matching in *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.1.2 :  

  |-------
{1}   sq(c!1) > 0
[2]   c!1 = 0

Rerunning step: (lemma "sq_nz_pos" ("nz" "c!1"))
Applying sq_nz_pos where 
  nz gets c!1,
this yields  2 subgoals: 
atanh_series.1.1.1.1.2.2.1.2.1 :  

{-1}  sq(c!1) > 0
  |-------
[1]   sq(c!1) > 0
[2]   c!1 = 0

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.2.2.1.2.1.

atanh_series.1.1.1.1.2.2.1.2.2 (TCC):   

  |-------
{1}   c!1 /= 0
[2]   sq(c!1) > 0
[3]   c!1 = 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.1.2.2.1.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.2.


This completes the proof of atanh_series.1.1.1.1.2.2.1.

atanh_series.1.1.1.1.2.2.2 :  

  |-------
{1}   even_fs?(atanhF(1 + n!1))
[2]   c!1 = 0
[3]   polynomial(atanhF(1 + n!1), 2 + 2 * n!1)(c!1) /
       (1 - sq(c!1)) ^ (3 + 2 * n!1)
       > 0

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.1.1.1.2.2.2 :  

  |-------
[1]   even_fs?(atanhF(1 + n!1))

Rerunning step: (expand "even_fs?")
Expanding the definition of even_fs?,
this simplifies to: 
atanh_series.1.1.1.1.2.2.2 :  

  |-------
{1}   FORALL (i: nat): odd?(i) => atanhF(1 + n!1)(i) = 0

Rerunning step: (expand "atanhF")
Expanding the definition of atanhF,
this simplifies to: 
atanh_series.1.1.1.1.2.2.2 :  

  |-------
{1}   FORALL (i: nat):
        odd?(i) =>
         IF i > 2 + 2 * n!1 OR odd?(i) THEN 0
         ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, i)
         ENDIF
          = 0

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.1.1.1.2.2.2 :  

{-1}  odd?(i!1)
  |-------
{1}   IF i!1 > 2 + 2 * n!1 OR odd?(i!1) THEN 0
      ELSE factorial(2 + 2 * n!1) * C(3 + 2 * n!1, i!1)
      ENDIF
       = 0

Rerunning step: (replace -1)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.1.1.1.2.2.2 :  

[-1]  odd?(i!1)
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of atanh_series.1.1.1.1.2.2.2.


This completes the proof of atanh_series.1.1.1.1.2.2.


This completes the proof of atanh_series.1.1.1.1.2.


This completes the proof of atanh_series.1.1.1.1.

atanh_series.1.1.1.2 (TCC):   

[-1]  (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[-2]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-3]  1 - sq(z!1) > 0
  |-------
{1}   (1 - sq(z!1)) ^ (3 + 2 * n!1) >= 0 AND
       (1 - sq(z!1)) ^ (3 + 2 * n!1) > 0
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.1.2.


This completes the proof of atanh_series.1.1.1.

atanh_series.1.1.2 (TCC):   

[-1]  abs(z!1 ^ (3 + 2 * n!1)) < 1
[-2]  1 - sq(z!1) > 0
  |-------
{1}   1 - sq(z!1) >= 0 AND 1 - sq(z!1) > 0
[2]   abs(atanhND(1 + n!1)(c!1)) * abs(z!1 ^ (3 + 2 * n!1)) /
       factorial(3 + 2 * n!1)
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.1.2.


This completes the proof of atanh_series.1.1.

atanh_series.1.2 :  

[-1]  1 - sq(z!1) > 0
  |-------
{1}   abs(z!1 ^ (3 + 2 * n!1)) < 1
[2]   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide -1 2)
Hiding formulas:  -1, 2,
this simplifies to: 
atanh_series.1.2 :  

  |-------
[1]   abs(z!1 ^ (3 + 2 * n!1)) < 1

Rerunning step: (case "FORALL (pn:posnat): abs(z!1^pn)<1")
Free variables in expr pn
Case splitting on 
   FORALL (pn: posnat): abs(z!1 ^ pn) < 1, 
this yields  2 subgoals: 
atanh_series.1.2.1 :  

{-1}  FORALL (pn: posnat): abs(z!1 ^ pn) < 1
  |-------
[1]   abs(z!1 ^ (3 + 2 * n!1)) < 1

Rerunning step: (inst - "3+2*n!1")
Instantiating the top quantifier in - with the terms: 
 3+2*n!1,

This completes the proof of atanh_series.1.2.1.

atanh_series.1.2.2 :  

  |-------
{1}   FORALL (pn: posnat): abs(z!1 ^ pn) < 1
[2]   abs(z!1 ^ (3 + 2 * n!1)) < 1

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.1.2.2 :  

  |-------
[1]   FORALL (pn: posnat): abs(z!1 ^ pn) < 1

Rerunning step: (induct "pn")
Inducting on pn on formula 1,
this yields  3 subgoals: 
atanh_series.1.2.2.1 :  

  |-------
{1}   pn!1 > 0
{2}   abs(z!1 ^ pn!1) < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.1.

atanh_series.1.2.2.2 :  

  |-------
{1}   0 > 0 IMPLIES abs(z!1 ^ 0) < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.2.

atanh_series.1.2.2.3 :  

  |-------
{1}   FORALL j:
        (j > 0 IMPLIES abs(z!1 ^ j) < 1) IMPLIES
         j + 1 > 0 IMPLIES abs(z!1 ^ (j + 1)) < 1

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
atanh_series.1.2.2.3 :  

{-1}  j!1 > 0 IMPLIES abs(z!1 ^ j!1) < 1
{-2}  j!1 + 1 > 0
  |-------
{1}   abs(z!1 ^ (j!1 + 1)) < 1

Rerunning step: (case-replace "j!1=0")
Assuming and applying j!1=0,
this yields  2 subgoals: 
atanh_series.1.2.2.3.1 :  

{-1}  j!1 = 0
{-2}  0 > 0 IMPLIES abs(z!1 ^ 0) < 1
{-3}  0 + 1 > 0
  |-------
{1}   abs(z!1 ^ (0 + 1)) < 1

Rerunning step: (rewrite "expt_x1")
Found matching substitution:
x: real gets z!1,
Rewriting using expt_x1, matching in *,
this simplifies to: 
atanh_series.1.2.2.3.1 :  

[-1]  j!1 = 0
[-2]  0 > 0 IMPLIES abs(z!1 ^ 0) < 1
[-3]  0 + 1 > 0
  |-------
{1}   abs(z!1) < 1

Rerunning step: (expand "abs")
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.2.2.3.1 :  

[-1]  j!1 = 0
{-2}  FALSE IMPLIES IF z!1 ^ 0 < 0 THEN -z!1 ^ 0 ELSE z!1 ^ 0 ENDIF < 1
[-3]  0 + 1 > 0
  |-------
{1}   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF < 1

Rerunning step: (case "z!1<0")
Case splitting on 
   z!1 < 0, 
this yields  2 subgoals: 
atanh_series.1.2.2.3.1.1 :  

{-1}  z!1 < 0
[-2]  j!1 = 0
[-3]  FALSE IMPLIES IF z!1 ^ 0 < 0 THEN -z!1 ^ 0 ELSE z!1 ^ 0 ENDIF < 1
[-4]  0 + 1 > 0
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.1.1.

atanh_series.1.2.2.3.1.2 :  

[-1]  j!1 = 0
[-2]  FALSE IMPLIES IF z!1 ^ 0 < 0 THEN -z!1 ^ 0 ELSE z!1 ^ 0 ENDIF < 1
[-3]  0 + 1 > 0
  |-------
{1}   z!1 < 0
[2]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.1.2.


This completes the proof of atanh_series.1.2.2.3.1.

atanh_series.1.2.2.3.2 :  

[-1]  j!1 > 0 IMPLIES abs(z!1 ^ j!1) < 1
[-2]  j!1 + 1 > 0
  |-------
{1}   j!1 = 0
[2]   abs(z!1 ^ (j!1 + 1)) < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
atanh_series.1.2.2.3.2 :  

{-1}  abs(z!1 ^ j!1) < 1
{-2}  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   abs(z!1 ^ (1 + j!1)) < 1

Rerunning step: (case-replace "z!1=0")
Assuming and applying z!1=0,
this yields  2 subgoals: 
atanh_series.1.2.2.3.2.1 :  

{-1}  z!1 = 0
{-2}  abs(0 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   abs(0 ^ (1 + j!1)) < 1

Rerunning step: (expand "^" 2)
Expanding the definition of ^,
this simplifies to: 
atanh_series.1.2.2.3.2.1 :  

[-1]  z!1 = 0
[-2]  abs(0 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   abs(expt(0, 1 + j!1)) < 1

Rerunning step: (expand "expt" 2)
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.2.2.3.2.1 :  

[-1]  z!1 = 0
[-2]  abs(0 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   abs(0 * expt(0, j!1)) < 1

Rerunning step: (expand "expt" 2)
Expanding the definition of expt,
this simplifies to: 
atanh_series.1.2.2.3.2.1 :  

[-1]  z!1 = 0
[-2]  abs(0 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   abs(0) < 1

Rerunning step: (expand "abs" 2)
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.2.2.3.2.1 :  

[-1]  z!1 = 0
[-2]  abs(0 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   j!1 = 0
{2}   0 < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.1.

atanh_series.1.2.2.3.2.2 :  

[-1]  abs(z!1 ^ j!1) < 1
[-2]  1 + j!1 > 0
  |-------
{1}   z!1 = 0
[2]   j!1 = 0
[3]   abs(z!1 ^ (1 + j!1)) < 1

Rerunning step: (lemma "expt_plus" ("n0x" "z!1" "i" "1" "j" "j!1"))
Applying expt_plus where 
  n0x gets z!1,
  i gets 1,
  j gets j!1,
this yields  2 subgoals: 
atanh_series.1.2.2.3.2.2.1 :  

{-1}  z!1 ^ (1 + j!1) = z!1 ^ 1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
[3]   abs(z!1 ^ (1 + j!1)) < 1

Rerunning step: (replace -1 3)
Replacing using formula -1,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1 :  

[-1]  z!1 ^ (1 + j!1) = z!1 ^ 1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
{3}   abs(z!1 ^ 1 * z!1 ^ j!1) < 1

Rerunning step: (rewrite "expt_x1" 3)
Found matching substitution:
x: real gets z!1,
Rewriting using expt_x1, matching in 3,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1 :  

{-1}  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
{3}   abs(z!1 * z!1 ^ j!1) < 1

Rerunning step: (rewrite "abs_mult" 3)
Found matching substitution:
y: real gets z!1 ^ j!1,
x gets z!1,
Rewriting using abs_mult, matching in 3,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1 :  

[-1]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
{3}   abs(z!1) * abs(z!1 ^ j!1) < 1

Rerunning step: (lemma "lt_times_lt_pos1"
                 ("px" "abs(z!1)" "y" "1" "nnz" "abs(z!1^j!1)" "w" "1"))
Applying lt_times_lt_pos1 where 
  px gets abs(z!1),
  y gets 1,
  nnz gets abs(z!1 ^ j!1),
  w gets 1,
this yields  2 subgoals: 
atanh_series.1.2.2.3.2.2.1.1 :  

{-1}  abs(z!1) <= 1 AND abs(z!1 ^ j!1) < 1 IMPLIES
       abs(z!1) * abs(z!1 ^ j!1) < 1 * 1
[-2]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-3]  abs(z!1 ^ j!1) < 1
[-4]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
[3]   abs(z!1) * abs(z!1 ^ j!1) < 1

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
atanh_series.1.2.2.3.2.2.1.1.1 :  

{-1}  abs(z!1) * abs(z!1 ^ j!1) < 1 * 1
[-2]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-3]  abs(z!1 ^ j!1) < 1
[-4]  1 + j!1 > 0
  |-------
[1]   z!1 = 0
[2]   j!1 = 0
[3]   abs(z!1) * abs(z!1 ^ j!1) < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.1.1.1.

atanh_series.1.2.2.3.2.2.1.1.2 :  

[-1]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
{1}   abs(z!1) <= 1
[2]   z!1 = 0
[3]   j!1 = 0
[4]   abs(z!1) * abs(z!1 ^ j!1) < 1

Rerunning step: (hide-all-but 1)
Keeping 1 and hiding *,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1.1.2 :  

  |-------
[1]   abs(z!1) <= 1

Rerunning step: (expand "abs")
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1.1.2 :  

  |-------
{1}   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF <= 1

Rerunning step: (case "z!1<0")
Case splitting on 
   z!1 < 0, 
this yields  2 subgoals: 
atanh_series.1.2.2.3.2.2.1.1.2.1 :  

{-1}  z!1 < 0
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF <= 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.1.1.2.1.

atanh_series.1.2.2.3.2.2.1.1.2.2 :  

  |-------
{1}   z!1 < 0
[2]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF <= 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.1.1.2.2.


This completes the proof of atanh_series.1.2.2.3.2.2.1.1.2.

atanh_series.1.2.2.3.2.2.1.1.3 :  

[-1]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
{1}   abs(z!1 ^ j!1) < 1
[2]   z!1 = 0
[3]   j!1 = 0
[4]   abs(z!1) * abs(z!1 ^ j!1) < 1

which is trivially true.

This completes the proof of atanh_series.1.2.2.3.2.2.1.1.3.


This completes the proof of atanh_series.1.2.2.3.2.2.1.1.

atanh_series.1.2.2.3.2.2.1.2 (TCC):   

[-1]  z!1 ^ (1 + j!1) = z!1 * z!1 ^ j!1
[-2]  abs(z!1 ^ j!1) < 1
[-3]  1 + j!1 > 0
  |-------
{1}   abs(z!1) > 0
[2]   z!1 = 0
[3]   j!1 = 0
[4]   abs(z!1) * abs(z!1 ^ j!1) < 1

Rerunning step: (hide-all-but (1 2))
Keeping (1 2) and hiding *,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1.2 :  

  |-------
[1]   abs(z!1) > 0
[2]   z!1 = 0

Rerunning step: (expand "abs")
Expanding the definition of abs,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1.2 :  

  |-------
{1}   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF > 0
[2]   z!1 = 0

Rerunning step: (lemma "trichotomy" ("x" "z!1"))
Applying trichotomy where 
  x gets z!1,
this simplifies to: 
atanh_series.1.2.2.3.2.2.1.2 :  

{-1}  z!1 > 0 OR z!1 = 0 OR 0 > z!1
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF > 0
[2]   z!1 = 0

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
atanh_series.1.2.2.3.2.2.1.2.1 :  

{-1}  z!1 > 0
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF > 0
[2]   z!1 = 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.1.2.1.

atanh_series.1.2.2.3.2.2.1.2.2 :  

{-1}  z!1 = 0
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF > 0
[2]   z!1 = 0

which is trivially true.

This completes the proof of atanh_series.1.2.2.3.2.2.1.2.2.

atanh_series.1.2.2.3.2.2.1.2.3 :  

{-1}  0 > z!1
  |-------
[1]   IF z!1 < 0 THEN -z!1 ELSE z!1 ENDIF > 0
[2]   z!1 = 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.1.2.3.


This completes the proof of atanh_series.1.2.2.3.2.2.1.2.


This completes the proof of atanh_series.1.2.2.3.2.2.1.

atanh_series.1.2.2.3.2.2.2 (TCC):   

[-1]  abs(z!1 ^ j!1) < 1
[-2]  1 + j!1 > 0
  |-------
{1}   z!1 /= 0
[2]   z!1 = 0
[3]   j!1 = 0
[4]   abs(z!1 ^ (1 + j!1)) < 1

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.1.2.2.3.2.2.2.


This completes the proof of atanh_series.1.2.2.3.2.2.


This completes the proof of atanh_series.1.2.2.3.2.


This completes the proof of atanh_series.1.2.2.3.


This completes the proof of atanh_series.1.2.2.


This completes the proof of atanh_series.1.2.


This completes the proof of atanh_series.1.

atanh_series.2 :  

  |-------
{1}   1 - sq(z!1) > 0
[2]   abs((atanhND(1 + n!1)(c!1) * z!1 ^ (3 + 2 * n!1)) /
           factorial(3 + 2 * n!1))
       <=
       ((1 - z!1) ^ (3 + 2 * n!1) + (1 + z!1) ^ (3 + 2 * n!1)) /
        (6 * (1 - sq(z!1)) ^ (3 + 2 * n!1) +
          4 * (((1 - sq(z!1)) ^ (3 + 2 * n!1)) * n!1))

Rerunning step: (hide 2)
Hiding formulas:  2,
this simplifies to: 
atanh_series.2 :  

  |-------
[1]   1 - sq(z!1) > 0

Rerunning step: (case "z!1>=0")
Case splitting on 
   z!1 >= 0, 
this yields  2 subgoals: 
atanh_series.2.1 :  

{-1}  z!1 >= 0
  |-------
[1]   1 - sq(z!1) > 0

Rerunning step: (lemma "sq_gt" ("nna" "1" "nnb" "z!1"))
Applying sq_gt where 
  nna gets 1,
  nnb gets z!1,
this yields  2 subgoals: 
atanh_series.2.1.1 :  

{-1}  sq(1) > sq(z!1) IFF 1 > z!1
[-2]  z!1 >= 0
  |-------
[1]   1 - sq(z!1) > 0

Rerunning step: (rewrite "sq_1")
Found matching substitution:
Rewriting using sq_1, matching in *,
this simplifies to: 
atanh_series.2.1.1 :  

{-1}  1 > sq(z!1) IFF 1 > z!1
[-2]  z!1 >= 0
  |-------
[1]   1 - sq(z!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.2.1.1.

atanh_series.2.1.2 (TCC):   

[-1]  z!1 >= 0
  |-------
{1}   z!1 >= 0
[2]   1 - sq(z!1) > 0

which is trivially true.

This completes the proof of atanh_series.2.1.2.


This completes the proof of atanh_series.2.1.

atanh_series.2.2 :  

  |-------
{1}   z!1 >= 0
[2]   1 - sq(z!1) > 0

Rerunning step: (lemma "sq_gt" ("nna" "1" "nnb" "-z!1"))
Applying sq_gt where 
  nna gets 1,
  nnb gets -z!1,
this yields  2 subgoals: 
atanh_series.2.2.1 :  

{-1}  sq(1) > sq(-z!1) IFF 1 > -z!1
  |-------
[1]   z!1 >= 0
[2]   1 - sq(z!1) > 0

Rerunning step: (rewrite "sq_1")
Found matching substitution:
Rewriting using sq_1, matching in *,
this simplifies to: 
atanh_series.2.2.1 :  

{-1}  1 > sq(-z!1) IFF 1 > -z!1
  |-------
[1]   z!1 >= 0
[2]   1 - sq(z!1) > 0

Rerunning step: (rewrite "sq_neg")
Found matching substitution:
a: real gets z!1,
Rewriting using sq_neg, matching in *,
this simplifies to: 
atanh_series.2.2.1 :  

{-1}  1 > sq(z!1) IFF 1 > -z!1
  |-------
[1]   z!1 >= 0
[2]   1 - sq(z!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.2.2.1.

atanh_series.2.2.2 (TCC):   

  |-------
{1}   -z!1 >= 0
[2]   z!1 >= 0
[3]   1 - sq(z!1) > 0

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,

This completes the proof of atanh_series.2.2.2.


This completes the proof of atanh_series.2.2.


This completes the proof of atanh_series.2.

Q.E.D.



Run time  = 18.02 secs.
Real time = 36.13 secs.

nil
pvs(26): 
