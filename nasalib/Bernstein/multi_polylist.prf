(multi_polylist
 (maxnum_TCC1 0
  (maxnum_TCC1-1 nil 3603213169 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (maxnum_TCC2 0
  (maxnum_TCC2-1 nil 3603213169 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (max_TCC1 0
  (max_TCC1-1 nil 3603199783 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (length def-decl "nat" list_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil))
   nil))
 (max_TCC2 0
  (max_TCC2-1 nil 3603207043 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil))
   nil))
 (max_TCC3 0
  (max_TCC3-1 nil 3603207043 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (max_TCC4 0
  (max_TCC4-1 nil 3603207043 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (max_TCC5 0
  (max_TCC5-1 nil 3603207043 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (length def-decl "nat" list_props nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil))
   nil))
 (max_TCC6 0
  (max_TCC6-1 nil 3603207043 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil))
   nil))
 (max_TCC7 0
  (max_TCC7-1 nil 3603207043 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil))
   nil))
 (max_TCC8 0
  (max_TCC8-1 nil 3603210536 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil))
   nil))
 (max_TCC9 0
  (max_TCC9-1 nil 3603210536 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil))
   nil))
 (max_TCC10 0
  (max_TCC10-1 nil 3603210536
   ("" (skeep)
    (("" (split)
      (("1" (expand "length" + 1)
        (("1" (assert)
          (("1" (expand "length" + 2)
            (("1" (expand "length" + 3)
              (("1" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))")
                (("1" (replaces -2)
                  (("1" (expand "maxnum" +)
                    (("1" (lift-if) (("1" (ground) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand "nth" + 1)
          (("2" (lift-if)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (assert)
                  (("2" (ground)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil)
                     ("4" (expand "length" -2)
                      (("4"
                        (typepred "v(cdr[nat](ml1), cdr[nat](ml2))")
                        (("4" (inst - "i-1")
                          (("4" (assert)
                            (("4" (lift-if)
                              (("4"
                                (ground)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil)
                                 ("5" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("5" (expand "length" -2)
                      (("5"
                        (typepred "v(cdr[nat](ml1), cdr[nat](ml2))")
                        (("5" (inst - "i-1")
                          (("5" (assert)
                            (("5" (lift-if) (("5" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("6" (expand "length" -1)
                      (("6"
                        (typepred "v(cdr[nat](ml1), cdr[nat](ml2))")
                        (("6" (inst - "i-1")
                          (("6" (assert) (("6" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (max_id 0
  (max_id-1 nil 3603440469
   ("" (induct "ml")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("rr" "ll"))
      (("2" (flatten)
        (("2" (expand "max" +)
          (("2" (expand "maxnum") (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (max_cdr_TCC1 0
  (max_cdr_TCC1-1 nil 3603447297 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (max_cdr 0
  (max_cdr-1 nil 3603447298
   (""
    (case "FORALL (ml1, ml2: MonoList,r1,r2:real):
        cdr(max(cons(r1,ml1), cons(r2,ml2))) = max(cdr(cons(r1,ml1)), cdr(cons(r2,ml2)))")
    (("1" (skeep)
      (("1" (inst - "cdr(ml1)" "cdr(ml2)" "car(ml1)" "car(ml2)")
        (("1" (assert)
          (("1"
            (case "FORALL (l:list[nat]): (NOT null?(l)) IMPLIES l = cons(car(l),cdr(l))")
            (("1" (rewrite -1 :dir rl)
              (("1" (rewrite -1 :dir rl) nil nil)) nil)
             ("2" (hide-all-but 1)
              (("2" (skeep) (("2" (decompose-equality 2) nil nil))
                nil))
              nil)
             ("3" (assert)
              (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (assert)
        (("2" (expand "max" + 1) (("2" (propax) nil nil)) nil)) nil))
      nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   shostak))
 (max_sym 0
  (max_sym-1 nil 3603445515
   ("" (induct "ml1")
    (("1" (grind)
      (("1" (expand "max" +)
        (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil))
      nil)
     ("2" (skolem 1 ("r" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "max" +)
            (("2" (lift-if)
              (("2" (ground)
                (("2" (case "maxnum(r,car(ml2)) = maxnum(car(ml2),r)")
                  (("1" (replace -1)
                    (("1" (inst - "cdr(ml2)") (("1" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (expand "maxnum" 1)
                    (("2" (lift-if)
                      (("2" (lift-if)
                        (("2" (lift-if) (("2" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (max_assoc 0
  (max_assoc-1 nil 3603446582
   ("" (induct "ml")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("r" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "max" + 4)
            (("2" (lift-if)
              (("2" (ground)
                (("1" (expand "max" + 2) (("1" (propax) nil nil)) nil)
                 ("2" (expand "max" + 1)
                  (("2" (assert)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("1" (grind) nil nil)
                         ("2" (expand "max" 2 1)
                          (("2" (assert)
                            (("2" (lift-if)
                              (("2"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (expand "max" + 3)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma "max_cdr")
                                          (("2"
                                            (inst - "ml1" "ml2")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (replaces -1)
                                                (("2"
                                                  (inst
                                                   -
                                                   "cdr(ml1)"
                                                   "cdr(ml2)")
                                                  (("2"
                                                    (replace -1)
                                                    (("2"
                                                      (expand "maxnum")
                                                      (("2"
                                                        (lift-if)
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (lift-if)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (lift-if)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_cdr formula-decl nil multi_polylist nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ml2 skolem-const-decl "MonoList" multi_polylist nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (varmono_TCC1 0
  (varmono_TCC1-1 nil 3603021513 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (varmono_TCC2 0
  (varmono_TCC2-1 nil 3603021513 ("" (termination-tcc) nil nil) nil
   nil))
 (monolist_eval_rec_TCC1 0
  (monolist_eval_rec_TCC1-1 nil 3604179743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (monolist_eval_rec_TCC2 0
  (monolist_eval_rec_TCC2-1 nil 3604179743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (monolist_eval_rec_TCC3 0
  (monolist_eval_rec_TCC3-1 nil 3604179743
   ("" (skeep)
    (("" (case-replace "length(ml) = 0")
      (("1" (grind) nil nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (gt_realorder name-judgement "RealOrder" util nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (product def-decl "real" product "reals/"))
   nil))
 (monolist_eval_rec_TCC4 0
  (monolist_eval_rec_TCC4-1 nil 3604179743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil))
   nil))
 (monolist_eval_rec_TCC5 0
  (monolist_eval_rec_TCC5-1 nil 3604179743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (monolist_eval_rec_TCC6 0
  (monolist_eval_rec_TCC6-1 nil 3604179743
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil))
 (monolist_eval_rec_TCC7 0
  (monolist_eval_rec_TCC7-1 nil 3604179743
   ("" (skeep)
    ((""
      (typepred
       "v(cdr[nat](ml), c * xvar(i) ^ car[nat](ml), i + 1)(xvar)")
      (("" (case "0 < length[nat](ml)")
        (("1" (rewrite "product_first" 2)
          (("1" (assert)
            (("1" (expand "nth" 2 1)
              (("1"
                (case "product(0, length(cdr[nat](ml)) - 1,
                LAMBDA (k: nat):
                  IF k < length(cdr[nat](ml))
                    THEN xvar(1 + k + i) ^ nth(cdr[nat](ml), k)
                  ELSE 1
                  ENDIF) = product(1, length[nat](ml) - 1,
                  LAMBDA (k: nat):
                    IF k < length[nat](ml)
                      THEN xvar(k + i) ^ nth[nat](ml, k)
                    ELSE 1
                    ENDIF)")
                (("1" (assert) nil nil)
                 ("2" (hide-all-but (-1 1 2))
                  (("2" (expand "length" 1 3)
                    (("2" (expand "length" 1 4)
                      (("2" (lemma "product_shift_T[nat]")
                        (("2"
                          (inst -1 _ "length(cdr[nat](ml)) - 1" "0"
                           "1")
                          (("2" (assert)
                            (("2" (inst?)
                              (("1"
                                (expand "nth" -1 2)
                                (("1"
                                  (case-replace
                                   "(LAMBDA (i_1: nat):
                 IF 1 + i_1 < 1 + length[nat](cdr(ml))
                   THEN xvar(1 + i_1 + i) ^ nth(cdr(ml), i_1)
                 ELSE 1
                 ENDIF) = (LAMBDA (k: nat):
                IF k < length(cdr[nat](ml))
                  THEN xvar(1 + k + i) ^ nth(cdr[nat](ml), k)
                ELSE 1
                ENDIF)")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (decompose-equality)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (grind) nil nil)
                                       ("4" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (hide-all-but 1)
                                    (("3" (grind) nil nil))
                                    nil)
                                   ("4"
                                    (hide-all-but 1)
                                    (("4" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2" (grind) nil nil))
                                nil)
                               ("3"
                                (hide-all-but 1)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)
                 ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (length def-decl "nat" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (product def-decl "real" product "reals/")
    (T_high type-eq-decl nil product "reals/")
    (T_low type-eq-decl nil product "reals/")
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (product_first formula-decl nil product "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (ml skolem-const-decl "MonoList" multi_polylist nil)
    (xvar skolem-const-decl "[nat -> real]" multi_polylist nil)
    (i skolem-const-decl "nat" multi_polylist nil)
    (expt def-decl "real" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (product_shift_T formula-decl nil product "reals/")
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (monolist_eval_prod_TCC1 0
  (monolist_eval_prod_TCC1-1 nil 3603468314 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (monolist_eval_prod 0
  (monolist_eval_prod-1 nil 3603468325
   ("" (skeep)
    (("" (expand "monolist_eval")
      (("" (typepred "monolist_eval_rec(ml, 1, 0)(xvar)")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((monolist_eval const-decl "real" multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (T_low type-eq-decl nil product "reals/")
    (T_high type-eq-decl nil product "reals/")
    (product def-decl "real" product "reals/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil))
   shostak))
 (monosum_TCC1 0
  (monosum_TCC1-1 nil 3603023858
   ("" (skeep*)
    (("" (expand "monolist_eval")
      (("" (expand "monolist_eval_rec" + 2) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((monolist_eval const-decl "real" multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil))
   nil))
 (monosum_TCC2 0
  (monosum_TCC2-1 nil 3603023858
   ("" (skeep*)
    (("" (expand "monolist_eval")
      (("" (expand "monolist_eval_rec" + 3) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((monolist_eval const-decl "real" multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil))
   nil))
 (monosum_TCC3 0
  (monosum_TCC3-3 "" 3604248507
   ("" (skeep*)
    (("" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))")
      (("" (hide -1)
        (("" (inst -1 "LAMBDA(i:nat):xvar(i+1)")
          (("" (expand "monolist_eval")
            (("" (expand "monolist_eval_rec" + 1)
              ((""
                (typepred
                 "monolist_eval_rec(v(cdr[nat](ml1), cdr[nat](ml2)),
                          1 * xvar(0) ^ (car[nat](ml1) + car[nat](ml2)), 1)
                         (xvar)")
                (("" (replaces -1)
                  (("" (expand "monolist_eval_rec" +)
                    (("" (assert)
                      ((""
                        (typepred
                         "monolist_eval_rec(cdr(ml1), 1 * xvar(0) ^ car(ml1), 1)(xvar)")
                        (("" (replaces -1)
                          ((""
                            (typepred
                             "monolist_eval_rec(cdr(ml2), 1 * xvar(0) ^ car(ml2), 1)(xvar)")
                            (("" (replaces -1)
                              ((""
                                (case
                                 "FORALL (x:real,j,k:nat): x^(j+k) = x^j*x^k")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (typepred
                                       "monolist_eval_rec(cdr[nat](ml1), 1, 0)(LAMBDA (i: nat): xvar(1 + i))")
                                      (("1"
                                        (typepred
                                         "monolist_eval_rec(cdr[nat](ml2), 1, 0)(LAMBDA (i: nat): xvar(1 + i))")
                                        (("1"
                                          (replaces (-1 -2) :dir rl)
                                          (("1"
                                            (typepred
                                             "monolist_eval_rec(v(cdr[nat](ml1), cdr[nat](ml2)), 1, 0)
                       (LAMBDA (i: nat): xvar(1 + i))")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (lemma "expt_plus")
                                    (("2"
                                      (case
                                       "FORALL (j,k:nat): 0^(j+k) = 0^j*0^k")
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (case "x = 0")
                                          (("1"
                                            (inst - "j" "k")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst - "j" "k" "x")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (case "k = 0")
                                            (("1"
                                              (replaces -1)
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (x skolem-const-decl "real" multi_polylist nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nat_expt application-judgement "nat" exponentiation nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expt def-decl "real" exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (T_low type-eq-decl nil product "reals/")
    (T_high type-eq-decl nil product "reals/")
    (product def-decl "real" product "reals/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
   shostak))
 (meval_TCC1 0
  (meval_TCC1-1 nil 3603036932 ("" (subtype-tcc) nil nil)
   ((MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (meval_TCC2 0
  (meval_TCC2-1 nil 3603036932 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (meval_TCC3 0
  (meval_TCC3-1 nil 3603036932 ("" (subtype-tcc) nil nil) nil nil))
 (meval_sigma_TCC1 0
  (meval_sigma_TCC1-1 nil 3603455463 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil))
   nil))
 (meval_sigma 0
  (meval_sigma-1 nil 3603455464
   ("" (induct "mpl")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("T" "L"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (inst - "xvar")
            (("2" (expand "meval" +)
              (("2" (lemma "sigma_split")
                (("2" (expand "length" + 1)
                  (("2" (assert)
                    (("2" (invoke (inst - "%1" _ _ _) (! 1 2 3))
                      (("2" (inst?)
                        (("2" (inst - "0")
                          (("2" (assert)
                            (("2" (replaces -1)
                              (("2"
                                (expand "sigma" + 1)
                                (("2"
                                  (expand "sigma" + 1)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "length" + 1)
                                      (("2"
                                        (expand "nth" + 3)
                                        (("2"
                                          (expand "nth" + 3)
                                          (("2"
                                            (replaces -1)
                                            (("2"
                                              (case
                                               "FORALL (k:nat): sigma(0, k,
            LAMBDA (i: nat):
              IF i < length(L)
                THEN nth(L, i)`1 * monolist_eval(nth(L, i)`2)(xvar)
              ELSE 0
              ENDIF)
       =
       sigma(1, k+1,
             LAMBDA (i: nat):
               IF i < length(cons(T, L))
                 THEN nth(cons(T, L), i)`1 *
                       monolist_eval(nth(cons(T, L), i)`2)(xvar)
               ELSE 0
               ENDIF)")
                                              (("1"
                                                (inst - "length(L)-1")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide 2)
                                                (("2"
                                                  (induct "k")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand "sigma")
                                                      (("1"
                                                        (expand
                                                         "sigma")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (ground)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("3"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (skolem 1 "k")
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand
                                                           "sigma"
                                                           +)
                                                          (("2"
                                                            (replaces
                                                             -1
                                                             :dir
                                                             rl)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (lift-if)
                                                                  (("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp*)
        (("3" (inst + "10") (("3" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sigma_0_neg formula-decl nil sigma_nat "reals/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (L skolem-const-decl "list[[real, MonoList]]" multi_polylist nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sigma_split formula-decl nil sigma "reals/")
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (meval def-decl "real" multi_polylist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (<= const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (degree_TCC1 0
  (degree_TCC1-1 nil 3603214067 ("" (subtype-tcc) nil nil)
   ((length_null formula-decl nil more_list_props "structures/")) nil))
 (degree_TCC2 0
  (degree_TCC2-1 nil 3603214067
   ("" (skeep)
    (("" (skeep)
      (("" (split)
        (("1" (typepred "i")
          (("1" (case "NOT i = 0")
            (("1" (grind) nil nil)
             ("2" (replaces -1)
              (("2" (expand "nth") (("2" (rewrite "max_id") nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "i")
          (("2" (case "NOT i = 0")
            (("1" (grind) nil nil)
             ("2" (replaces -1)
              (("2" (expand "nth") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (length def-decl "nat" list_props nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (max_id formula-decl nil multi_polylist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (degree_TCC3 0
  (degree_TCC3-1 nil 3603214067
   ("" (skeep) (("" (expand "length" + 2) (("" (assert) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (degree_TCC4 0
  (degree_TCC4-1 nil 3603214067
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(cdr[[real, MonoList]](mpl))")
        (("1" (hide -1)
          (("1" (assert)
            (("1" (split)
              (("1" (case "i = 0")
                (("1" (replaces -1)
                  (("1" (expand "nth" +)
                    (("1" (assert)
                      (("1"
                        (case "FORALL (l1,l2:list[nat]): max(l1,l2) = max(l1,max(l1,l2))")
                        (("1" (inst?) nil nil)
                         ("2" (hide-all-but 1)
                          (("2" (induct "l1")
                            (("1" (grind) nil nil)
                             ("2" (skolem 1 ("r" "l"))
                              (("2"
                                (flatten)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (expand "max" +)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (lift-if)
                                          (("2"
                                            (lift-if)
                                            (("2"
                                              (ground)
                                              (("1"
                                                (expand "maxnum" +)
                                                (("1"
                                                  (rewrite "max_id" +)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (case
                                                 "maxnum(r, maxnum(r, car(l2))) = maxnum(r,car(l2))")
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (inst
                                                       -
                                                       "cdr(l2)")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (name "V" "v(cdr[[real, MonoList]](mpl))")
                    (("2" (replace -1)
                      (("2" (inst - "i-1")
                        (("1" (expand "nth" +)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (rewrite "max_assoc" +)
                                (("1"
                                  (lemma "max_sym")
                                  (("1"
                                    (inst
                                     -
                                     "nth(cdr(mpl), i - 1)`2"
                                     "car[[real, MonoList]](mpl)`2")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (rewrite "max_assoc" + :dir rl)
                                        (("1"
                                          (lemma "max_sym")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2" (typepred "i")
                            (("2" (expand "length" -1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2"
                  (typepred "max(car[[real, MonoList]](mpl)`2,
               v(cdr[[real, MonoList]](mpl)))")
                  (("2" (replace -2)
                    (("2" (assert)
                      (("2" (case "i = 0")
                        (("1" (replaces -1)
                          (("1" (expand "nth" 1)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (inst -4 "i-1")
                          (("1" (expand "nth" 2)
                            (("1" (assert) nil nil)) nil)
                           ("2" (assert)
                            (("2" (typepred "i")
                              (("2"
                                (expand "length" -1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (max_sym formula-decl nil multi_polylist nil)
    (max_assoc formula-decl nil multi_polylist nil)
    (i skolem-const-decl "below(length(mpl))" multi_polylist nil)
    (mpl skolem-const-decl "MultiPolyList" multi_polylist nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_id formula-decl nil multi_polylist nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (< const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil))
   nil))
 (degree_zero 0
  (degree_zero-1 nil 3603531482
   ("" (induct "mpl")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("rp" "lmp"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case "i = 0")
            (("1" (assert)
              (("1" (replaces -1)
                (("1" (expand "degree" -2)
                  (("1" (lift-if)
                    (("1" (expand "nth" 1)
                      (("1" (ground)
                        (("1" (hide -2)
                          (("1" (expand "max" -1)
                            (("1" (lift-if) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "max" -1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (split -1)
              (("1" (inst - "i-1")
                (("1" (assert)
                  (("1" (split -1)
                    (("1" (expand "nth" +) (("1" (propax) nil nil))
                      nil)
                     ("2" (expand "length" -2) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("2" (assert)
                (("2" (expand "degree" -1)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (expand "degree" 1)
                        (("1" (propax) nil nil)) nil)
                       ("2" (expand "max" -1)
                        (("2" (lift-if) (("2" (ground) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "nat" multi_polylist nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (degree def-decl "{ml |
         (NOT null?(mpl)) IMPLIES
          (FORALL (i: below(length(mpl))):
             ml = max(nth(mpl, i)`2, ml) AND
              length(ml) >= length(nth(mpl, i)`2))}" multi_polylist
     nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil))
   shostak))
 (multipoly_to_mpoly_TCC1 0
  (multipoly_to_mpoly_TCC1-1 nil 3603451460 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" util nil))
   nil))
 (mp_simp_rec_TCC1 0
  (mp_simp_rec_TCC1-1 nil 3603033743
   ("" (skeep)
    (("" (skeep)
      (("" (expand "meval" +)
        (("" (assert)
          (("" (expand "meval" + 1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (meval def-decl "real" multi_polylist nil))
   nil))
 (mp_simp_rec_TCC2 0
  (mp_simp_rec_TCC2-1 nil 3603033743
   ("" (skeep)
    (("" (assert)
      (("" (flatten)
        (("" (replaces -1)
          (("" (replaces -3)
            (("" (assert) (("" (skeep) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (meval def-decl "real" multi_polylist nil))
   nil))
 (mp_simp_rec_TCC3 0
  (mp_simp_rec_TCC3-1 nil 3603033743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (mp_simp_rec_TCC4 0
  (mp_simp_rec_TCC4-1 nil 3603033743 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil)
    (length def-decl "nat" list_props nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (mp_simp_rec_TCC5 0
  (mp_simp_rec_TCC5-1 nil 3603033743
   ("" (skeep)
    (("" (skeep)
      (("" (assert)
        (("" (hide 3)
          ((""
            (typepred
             "v(null[[real, MonoList]], cdr[[real, MonoList]](swiped),
              cons[[real, MonoList]]((thiscoeff, mono), ans),
              car[[real, MonoList]](swiped)`2,
              car[[real, MonoList]](swiped)`1)")
            (("" (rewrite -1)
              (("" (hide -1)
                (("" (expand "meval" + 3)
                  (("" (expand "meval" + 2)
                    (("" (expand "meval" + 3)
                      (("" (expand "meval" + 2) (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mp_simp_rec_TCC6 0
  (mp_simp_rec_TCC6-1 nil 3603033743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (mp_simp_rec_TCC7 0
  (mp_simp_rec_TCC7-1 nil 3603033743 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< def-decl "bool" ordinals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil)
    (length def-decl "nat" list_props nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (mp_simp_rec_TCC8 0
  (mp_simp_rec_TCC8-1 nil 3603033743
   ("" (skeep)
    (("" (skeep)
      ((""
        (typepred
         "v(null[[real, MonoList]], cdr[[real, MonoList]](swiped), ans,
              car[[real, MonoList]](swiped)`2,
              car[[real, MonoList]](swiped)`1)")
        (("" (rewrite -1)
          (("" (hide -1)
            (("" (expand "meval" + 3)
              (("" (assert)
                (("" (hide 3)
                  (("" (expand "meval" + 3)
                    (("" (flatten)
                      (("" (replaces -2)
                        (("" (assert)
                          (("" (expand "meval" + 2)
                            (("" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mp_simp_rec_TCC9 0
  (mp_simp_rec_TCC9-1 nil 3603033743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (mp_simp_rec_TCC10 0
  (mp_simp_rec_TCC10-1 nil 3603033743 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil)
    (< def-decl "bool" ordinals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (lex2 const-decl "ordinal" lex2 nil))
   nil))
 (mp_simp_rec_TCC11 0
  (mp_simp_rec_TCC11-1 nil 3603033743
   ("" (skeep)
    (("" (skeep)
      ((""
        (typepred "v(swiped, cdr[[real, MonoList]](toswipe), ans, mono,
              car[[real, MonoList]](toswipe)`1 + thiscoeff)")
        (("" (rewrite -1)
          (("" (hide -1)
            (("" (assert)
              (("" (hide (2 3 4))
                (("" (assert)
                  ((""
                    (both-sides -
                     "monolist_eval(mono)(xvar) * thiscoeff" 2)
                    (("" (assert)
                      ((""
                        (case "NOT meval(toswipe)(xvar) - monolist_eval(mono)(xvar) * thiscoeff +
        thiscoeff * monolist_eval(mono)(xvar) = meval(toswipe)(xvar)")
                        (("1" (assert) nil nil)
                         ("2" (replaces -1)
                          (("2" (expand "meval" + 2)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((both_sides_plus1 formula-decl nil real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mp_simp_rec_TCC12 0
  (mp_simp_rec_TCC12-1 nil 3603033743 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (< def-decl "bool" ordinals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (/= const-decl "boolean" notequal nil)
    (length def-decl "nat" list_props nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (mp_simp_rec_TCC13 0
  (mp_simp_rec_TCC13-1 nil 3603033743
   ("" (skeep)
    (("" (skeep)
      ((""
        (typepred "v(cons[[real, MonoList]]
                  (car[[real, MonoList]](toswipe), swiped),
              cdr[[real, MonoList]](toswipe), ans, mono, thiscoeff)")
        (("" (rewrite -1)
          (("" (hide -1)
            (("" (assert)
              (("" (hide (3 4 5))
                (("" (expand "meval" + 2)
                  (("" (expand "meval" + 2) (("" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mp_simp_TCC1 0
  (mp_simp_TCC1-1 nil 3603028950
   ("" (skeep)
    (("" (assert)
      ((""
        (typepred "mp_simp_rec(null[[real, MonoList]], mpl,
                         null[[real, MonoList]],
                         car[[real, MonoList]](mpl)`2, 0)")
        (("" (decompose-equality +)
          (("" (inst - "x!1")
            (("" (replaces -1)
              (("" (expand "meval" + 3) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (mp_simp_rec def-decl "{mpl |
         FORALL (xvar):
           meval(mpl)(xvar) =
            meval(swiped)(xvar) + meval(toswipe)(xvar) + meval(ans)(xvar) +
             thiscoeff * monolist_eval(mono)(xvar)}" multi_polylist
     nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mpconst_TCC1 0
  (mpconst_TCC1-1 nil 3603035287 ("" (grind) nil nil)
   ((every adt-def-decl "boolean" list_adt nil)) nil))
 (mpsum_TCC1 0
  (mpsum_TCC1-1 nil 3603036932
   (""
    (case "FORALL (mpl1: MultiPolyList, mpl2: MultiPolyList):
               meval(append[[real, MonoList]](mpl1, mpl2)) =
                (+[[nat->real]])(meval(mpl1), meval(mpl2))")
    (("1" (skeep)
      (("1" (insteep -1)
        (("1"
          (typepred "mp_simp(append[[real, MonoList]](mpl1, mpl2))")
          (("1" (assert) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "mpl1")
        (("1" (expand "+")
          (("1" (skeep)
            (("1" (decompose-equality +)
              (("1" (expand "append")
                (("1" (expand "meval") (("1" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem 1 ("X" "L"))
          (("2" (flatten)
            (("2" (skeep)
              (("2" (expand "append" +)
                (("2" (expand "meval" + 1)
                  (("2" (decompose-equality +)
                    (("2" (inst - "mpl2")
                      (("2" (decompose-equality -)
                        (("2" (inst - "x!1")
                          (("2" (expand "+")
                            (("2" (expand "meval" + 2)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (list_induction formula-decl nil list_adt nil)
    (mp_simp const-decl
     "{mulist: MultiPolyList | meval(mpl) = meval(mulist)}"
     multi_polylist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (meval def-decl "real" multi_polylist nil)
    (append def-decl "list[T]" list_props nil)
    (+ const-decl "[T -> real]" real_fun_ops "reals/"))
   nil))
 (mpprod_rec_TCC1 0
  (mpprod_rec_TCC1-1 nil 3603106487 ("" (grind) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (meval def-decl "real" multi_polylist nil))
   nil))
 (mpprod_rec_TCC2 0
  (mpprod_rec_TCC2-1 nil 3603106487 ("" (grind) nil nil)
   ((monolist_eval const-decl "real" multi_polylist nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (meval def-decl "real" multi_polylist nil))
   nil))
 (mpprod_rec_TCC3 0
  (mpprod_rec_TCC3-1 nil 3603106487 ("" (grind) nil nil) nil nil))
 (mpprod_rec_TCC4 0
  (mpprod_rec_TCC4-1 nil 3603106487 ("" (grind) nil nil)
   ((every adt-def-decl "boolean" list_adt nil)) nil))
 (mpprod_rec_TCC5 0
  (mpprod_rec_TCC5-1 nil 3603106487
   ("" (skeep)
    (("" (skeep)
      (("" (expand "meval" + 1)
        (("" (expand "meval" + 1)
          (("" (expand "meval")
            (("" (assert)
              ((""
                (typepred "monosum(car[[real, MonoList]](mpl1)`2,
                              car[[real, MonoList]](mpl2)`2)")
                (("" (hide -1)
                  (("" (rewrite -1)
                    (("" (assert)
                      (("" (hide -1)
                        (("" (expand "meval" +) (("" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (monosum def-decl "{pml2: MonoList |
         FORALL (xvar):
           monolist_eval(pml2)(xvar) =
            monolist_eval(ml1)(xvar) * monolist_eval(ml2)(xvar)}"
     multi_polylist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mpprod_rec_TCC6 0
  (mpprod_rec_TCC6-1 nil 3603106487 ("" (termination-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (mpprod_rec_TCC7 0
  (mpprod_rec_TCC7-1 nil 3603106487 ("" (termination-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (mpprod_rec_TCC8 0
  (mpprod_rec_TCC8-1 nil 3603106487
   ("" (skeep)
    (("" (skeep)
      (("" (assert)
        (("" (expand "+")
          ((""
            (typepred "mpsum(v(mpl1, cdr[[real, MonoList]](mpl2)),
                  v(mpl1, (: car[[real, MonoList]](mpl2) :)))")
            (("" (replaces -1)
              (("" (assert)
                (("" (expand "+")
                  (("" (assert)
                    ((""
                      (typepred "v(mpl1, cdr[[real, MonoList]](mpl2))")
                      (("" (rewrite -1)
                        (("" (hide -1)
                          (("" (assert)
                            ((""
                              (typepred
                               "v(mpl1, (: car[[real, MonoList]](mpl2) :))")
                              ((""
                                (rewrite -1)
                                ((""
                                  (hide -1)
                                  ((""
                                    (assert)
                                    ((""
                                      (expand "meval" + 4)
                                      ((""
                                        (assert)
                                        ((""
                                          (case
                                           "meval(cdr[[real, MonoList]](mpl2))(xvar) +
       meval((: :))(xvar)
       +
        monolist_eval(car[[real, MonoList]](mpl2)`2)(xvar)
        * car[[real, MonoList]](mpl2)`1
       = meval(mpl2)(xvar)")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (hide 5)
                                            (("2"
                                              (expand "meval" + 2)
                                              (("2"
                                                (expand "meval" + 2)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ macro-decl "MultiPolyList" multi_polylist nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (+ const-decl "[T -> real]" real_fun_ops "reals/")
    (mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}"
     multi_polylist nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (mpprod_rec_TCC9 0
  (mpprod_rec_TCC9-1 nil 3603106487 ("" (termination-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (mpprod_rec_TCC10 0
  (mpprod_rec_TCC10-1 nil 3603106487 ("" (termination-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (mpprod_rec_TCC11 0
  (mpprod_rec_TCC11-1 nil 3603106487
   ("" (skeep)
    (("" (skeep)
      (("" (expand "+")
        ((""
          (typepred "mpsum(v(cdr[[real, MonoList]](mpl1), mpl2),
                  v((: car[[real, MonoList]](mpl1) :), mpl2))")
          (("" (replace -1)
            (("" (hide -1)
              (("" (expand "+")
                (("" (typepred "v(cdr[[real, MonoList]](mpl1), mpl2)")
                  (("" (rewrite -1)
                    (("" (hide -1)
                      ((""
                        (typepred
                         "v((: car[[real, MonoList]](mpl1) :), mpl2)")
                        (("" (rewrite -1)
                          (("" (hide -1)
                            (("" (assert)
                              ((""
                                (hide 2)
                                ((""
                                  (expand "meval" + 3)
                                  ((""
                                    (expand "meval" + 4)
                                    ((""
                                      (assert)
                                      ((""
                                        (expand "meval" + 4)
                                        (("" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}"
     multi_polylist nil)
    (+ const-decl "[T -> real]" real_fun_ops "reals/")
    (meval def-decl "real" multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (+ macro-decl "MultiPolyList" multi_polylist nil))
   nil))
 (mpprod_TCC1 0
  (mpprod_TCC1-1 nil 3603041774
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "mp_simp(mpprod_rec(mpl1, mpl2))")
        (("" (replaces -1 :dir rl)
          (("" (typepred "mpprod_rec(mpl1, mpl2)")
            (("" (rewrite -1) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mpprod_rec def-decl "{mpl |
         FORALL (xvar):
           meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}"
     multi_polylist nil)
    (mp_simp const-decl
     "{mulist: MultiPolyList | meval(mpl) = meval(mulist)}"
     multi_polylist nil))
   nil))
 (mpscal_TCC1 0
  (mpscal_TCC1-1 nil 3603108317
   ("" (skeep) (("" (expand "length" + 2) (("" (assert) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (mppow_TCC1 0
  (mppow_TCC1-1 nil 3603099886 ("" (grind) nil nil)
   ((every adt-def-decl "boolean" list_adt nil)) nil))
 (multipolylist_eval_TCC1 0
  (multipolylist_eval_TCC1-1 nil 3603453411 ("" (subtype-tcc) nil nil)
   ((gt_realorder name-judgement "RealOrder" util nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (multipolylist_eval 0
  (multipolylist_eval-1 nil 3603454251
   ("" (skeep)
    (("" (case "null?(mpl)")
      (("1" (expand "meval" + 1)
        (("1" (assert)
          (("1" (expand "multipoly_to_mpoly" + 4)
            (("1" (assert)
              (("1" (case "length(mpl)=0")
                (("1" (assert)
                  (("1" (expand "multipoly_to_mpoly" + 3)
                    (("1" (expand "multipoly_eval")
                      (("1" (expand "sigma")
                        (("1" (expand "sigma") (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "length(mpl)=0")
        (("1" (hide 2) (("1" (grind) nil nil)) nil)
         ("2" (rewrite "meval_sigma")
          (("2" (expand "multipoly_eval" + 1)
            (("2" (expand "multipoly_to_mpoly" + 1)
              (("2" (assert)
                (("2" (rewrite "sigma_eq")
                  (("2" (hide 4)
                    (("2" (skolem 1 "t")
                      (("2"
                        (case "monolist_eval(nth(mpl, t)`2)(xvar) =
                                                        polyproduct_eval(multipoly_to_mpoly(mpl)`mpoly(t),
                                                                         multipoly_to_mpoly(mpl)`mdeg,
                                                                         max(length(degree(mpl)), 1))
                                                                        (xvar)")
                        (("1" (expand "multipoly_to_mpoly" + 1)
                          (("1" (assert) nil nil)) nil)
                         ("2" (hide 2)
                          (("2" (rewrite "monolist_eval_prod")
                            (("2" (expand "polyproduct_eval")
                              (("2"
                                (expand "multipoly_to_mpoly" + 2)
                                (("2"
                                  (case "length(degree(mpl))=0")
                                  (("1"
                                    (case "degree(mpl) = null")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "max")
                                          (("1"
                                            (expand "list2array" + 1)
                                            (("1"
                                              (expand
                                               "multipoly_to_mpoly"
                                               +
                                               1)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   "product"
                                                   +
                                                   2)
                                                  (("1"
                                                    (expand
                                                     "product"
                                                     +
                                                     2)
                                                    (("1"
                                                      (lemma
                                                       "degree_zero")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -
                                                             "t")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "length"
                                                                 +
                                                                 1)
                                                                (("1"
                                                                  (expand
                                                                   "product"
                                                                   +)
                                                                  (("1"
                                                                    (expand
                                                                     "multipoly_to_poly"
                                                                     +
                                                                     1)
                                                                    (("1"
                                                                      (expand
                                                                       "polynomial")
                                                                      (("1"
                                                                        (expand
                                                                         "sigma")
                                                                        (("1"
                                                                          (expand
                                                                           "sigma")
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2)
                                      (("2"
                                        (grind :exclude "degree")
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "max")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (case "null?(degree(mpl))")
                                        (("1"
                                          (hide 2)
                                          (("1"
                                            (grind :exclude "degree")
                                            nil
                                            nil))
                                          nil)
                                         ("2"
                                          (invoke
                                           (name "AA" "%1")
                                           (! 3 1))
                                          (("1"
                                            (replaces -1)
                                            (("1"
                                              (lemma
                                               "product_split[nat]")
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (expand "AA")
                                                  (("1"
                                                    (inst
                                                     -
                                                     "length(nth(mpl, t)`2) - 1")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (split -1)
                                                        (("1"
                                                          (case
                                                           "FORALL (k:nat): product(length(nth(mpl, t)`2), k,
                                                          LAMBDA (i: nat):
                                                            polynomial(multipoly_to_mpoly(mpl)`mpoly(t)(i),
                                                                       list2array[nat](0)(degree(mpl))(i))
                                                                      (xvar(i))) = 1")
                                                          (("1"
                                                            (inst?)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (replaces
                                                                 -1)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (replaces
                                                                     -1)
                                                                    (("1"
                                                                      (rewrite
                                                                       "product_eq")
                                                                      (("1"
                                                                        (hide
                                                                         4)
                                                                        (("1"
                                                                          (skeep)
                                                                          (("1"
                                                                            (expand
                                                                             "multipoly_to_mpoly")
                                                                            (("1"
                                                                              (expand
                                                                               "polynomial")
                                                                              (("1"
                                                                                (lemma
                                                                                 "sigma_eq_one_arg")
                                                                                (("1"
                                                                                  (inst?)
                                                                                  (("1"
                                                                                    (inst
                                                                                     -
                                                                                     "nth(nth(mpl, t)`2, n)")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (split
                                                                                         -)
                                                                                        (("1"
                                                                                          (replaces
                                                                                           -1)
                                                                                          (("1"
                                                                                            (expand
                                                                                             "multipoly_to_poly")
                                                                                            (("1"
                                                                                              (lift-if)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                (("1"
                                                                                                  (ground)
                                                                                                  (("1"
                                                                                                    (replaces
                                                                                                     -1)
                                                                                                    (("1"
                                                                                                      (hide-all-but
                                                                                                       1)
                                                                                                      (("1"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (lemma
                                                                                           "list2array_sound[nat]")
                                                                                          (("2"
                                                                                            (inst?)
                                                                                            (("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (replaces
                                                                                                 -1)
                                                                                                (("2"
                                                                                                  (lift-if)
                                                                                                  (("2"
                                                                                                    (ground)
                                                                                                    (("1"
                                                                                                      (typepred
                                                                                                       "degree(mpl)")
                                                                                                      (("1"
                                                                                                        (assert)
                                                                                                        (("1"
                                                                                                          (hide
                                                                                                           -1)
                                                                                                          (("1"
                                                                                                            (inst
                                                                                                             -
                                                                                                             "t")
                                                                                                            (("1"
                                                                                                              (flatten)
                                                                                                              (("1"
                                                                                                                (assert)
                                                                                                                (("1"
                                                                                                                  (typepred
                                                                                                                   "max(nth(mpl, t)`2, degree(mpl))")
                                                                                                                  (("1"
                                                                                                                    (inst
                                                                                                                     -
                                                                                                                     "n")
                                                                                                                    (("1"
                                                                                                                      (assert)
                                                                                                                      (("1"
                                                                                                                        (lift-if)
                                                                                                                        (("1"
                                                                                                                          (ground)
                                                                                                                          (("1"
                                                                                                                            (typepred
                                                                                                                             "n")
                                                                                                                            (("1"
                                                                                                                              (hide-all-but
                                                                                                                               (-2
                                                                                                                                -3))
                                                                                                                              (("1"
                                                                                                                                (grind
                                                                                                                                 :exclude
                                                                                                                                 "nth")
                                                                                                                                nil
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil)
                                                                                                     ("2"
                                                                                                      (typepred
                                                                                                       "n")
                                                                                                      (("2"
                                                                                                        (typepred
                                                                                                         "degree(mpl)")
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          (("2"
                                                                                                            (inst
                                                                                                             -
                                                                                                             "t")
                                                                                                            (("2"
                                                                                                              (assert)
                                                                                                              nil
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("3"
                                                                                          (hide
                                                                                           2)
                                                                                          (("3"
                                                                                            (skosimp*)
                                                                                            (("3"
                                                                                              (typepred
                                                                                               "i!1")
                                                                                              (("3"
                                                                                                (lift-if)
                                                                                                (("3"
                                                                                                  (assert)
                                                                                                  (("3"
                                                                                                    (ground)
                                                                                                    (("1"
                                                                                                      (replaces
                                                                                                       -1)
                                                                                                      (("1"
                                                                                                        (assert)
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           "multipoly_to_poly")
                                                                                                          (("1"
                                                                                                            (lift-if)
                                                                                                            (("1"
                                                                                                              (ground)
                                                                                                              (("1"
                                                                                                                (typepred
                                                                                                                 "n")
                                                                                                                (("1"
                                                                                                                  (grind)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil)
                                                                                                     ("2"
                                                                                                      (expand
                                                                                                       "multipoly_to_poly")
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("4"
                                                                                          (hide
                                                                                           2)
                                                                                          (("4"
                                                                                            (skosimp*)
                                                                                            (("4"
                                                                                              (ground)
                                                                                              (("4"
                                                                                                (expand
                                                                                                 "multipoly_to_poly")
                                                                                                (("4"
                                                                                                  (assert)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         4)
                                                                        (("2"
                                                                          (skeep)
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide 4)
                                                            (("2"
                                                              (hide -1)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (skeep)
                                                                  (("2"
                                                                    (rewrite
                                                                     "product_1")
                                                                    (("2"
                                                                      (hide
                                                                       2)
                                                                      (("2"
                                                                        (skeep)
                                                                        (("2"
                                                                          (typepred
                                                                           "n")
                                                                          (("2"
                                                                            (expand
                                                                             "multipoly_to_mpoly")
                                                                            (("2"
                                                                              (expand
                                                                               "multipoly_to_poly")
                                                                              (("2"
                                                                                (expand
                                                                                 "polynomial")
                                                                                (("2"
                                                                                  (lemma
                                                                                   "sigma_eq_one_arg")
                                                                                  (("2"
                                                                                    (inst?)
                                                                                    (("2"
                                                                                      (inst
                                                                                       -
                                                                                       "0")
                                                                                      (("2"
                                                                                        (assert)
                                                                                        (("2"
                                                                                          (hide
                                                                                           2)
                                                                                          (("2"
                                                                                            (skosimp*)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (typepred
                                                             "degree(mpl)")
                                                            (("2"
                                                              (hide -1)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (inst
                                                                   -
                                                                   "t")
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide 4)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (skeep)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((MultiPolyList type-eq-decl nil multi_polylist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (multipoly_eval const-decl "real" multi_polynomial nil)
    (sigma def-decl "real" sigma "reals/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (multipoly_to_mpoly const-decl "MPoly" multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (meval_sigma formula-decl nil multi_polylist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" util nil)
    (sigma_eq formula-decl nil sigma "reals/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (Coeff type-eq-decl nil util nil)
    (DegreeMono type-eq-decl nil util nil)
    (MultiPolynomial type-eq-decl nil util nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (MPoly type-eq-decl nil MPoly nil)
    (Polynomial type-eq-decl nil util nil)
    (Polyproduct type-eq-decl nil util nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil) (Vars type-eq-decl nil util nil)
    (polyproduct_eval const-decl "real" multi_polynomial nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (maxnum const-decl
     "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist
     nil)
    (max def-decl "{ml |
         length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
          (FORALL (i: nat):
             i < length(ml) IMPLIES
              nth(ml, i) =
               IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
               ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
               ELSE maxnum(nth(ml1, i), nth(ml2, i))
               ENDIF)}" multi_polylist nil)
    (degree def-decl "{ml |
         (NOT null?(mpl)) IMPLIES
          (FORALL (i: below(length(mpl))):
             ml = max(nth(mpl, i)`2, ml) AND
              length(ml) >= length(nth(mpl, i)`2))}" multi_polylist
     nil)
    (<= const-decl "bool" reals nil)
    (T_high type-eq-decl nil sigma "reals/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T_low type-eq-decl nil sigma "reals/")
    (product def-decl "real" product "reals/")
    (degree_zero formula-decl nil multi_polylist nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (multipoly_to_poly const-decl "real" multi_polylist nil)
    (list2array def-decl "T" array2list "structures/")
    (length_null formula-decl nil more_list_props "structures/")
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (T_high type-eq-decl nil product "reals/")
    (T_low type-eq-decl nil product "reals/")
    (product_split formula-decl nil product "reals/")
    (AA skolem-const-decl "real" multi_polylist nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (product_eq formula-decl nil product "reals/")
    (list2array_sound formula-decl nil array2list "structures/")
    (expt def-decl "real" exponentiation nil)
    (sigma_eq_one_arg formula-decl nil sigma "reals/")
    (product_1 formula-decl nil product "reals/")
    (sequence type-eq-decl nil sequences nil)
    (monolist_eval_prod formula-decl nil multi_polylist nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (subrange type-eq-decl nil integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (multipolylist_const 0
  (multipolylist_const-1 nil 3603035288 ("" (grind) nil nil)
   ((mpconst const-decl "MultiPolyList" multi_polylist nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (meval def-decl "real" multi_polylist nil))
   shostak))
 (multipolylist_monom_TCC1 0
  (multipolylist_monom_TCC1-1 nil 3603035287 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (multipolylist_monom 0
  (multipolylist_monom-2 "" 3604251987
   ("" (induct "i")
    (("1" (skeep)
      (("1" (expand "mpmonom")
        (("1" (expand "meval")
          (("1" (expand "meval")
            (("1" (expand "varmono")
              (("1" (expand "monolist_eval")
                (("1" (expand "monolist_eval_rec")
                  (("1" (expand "monolist_eval_rec")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (inst - "c" "n" "LAMBDA(i:nat):xvar(i+1)")
        (("2" (expand "mpmonom")
          (("2" (expand "varmono" +)
            (("2" (expand "meval" +)
              (("2" (expand "meval" + 1)
                (("2" (expand "meval" -)
                  (("2" (expand "meval" - 1)
                    (("2" (expand "monolist_eval" +)
                      (("2" (expand "monolist_eval_rec")
                        (("2" (expand "^" + 1)
                          (("2" (expand "expt")
                            (("2" (expand "monolist_eval")
                              (("2"
                                (typepred
                                 "monolist_eval_rec(varmono(j, n), 1, 0)(LAMBDA (i: nat): xvar(1 + i))")
                                (("2"
                                  (typepred
                                   "monolist_eval_rec(varmono(j, n), 1, 1)(xvar)")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (le_realorder name-judgement "RealOrder" util nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" util nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (T_low type-eq-decl nil product "reals/")
    (T_high type-eq-decl nil product "reals/")
    (product def-decl "real" product "reals/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (expt def-decl "real" exponentiation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (varmono def-decl "MonoList" multi_polylist nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (mpmonom const-decl "MultiPolyList" multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (multipolylist_var 0
  (multipolylist_var-1 nil 3604151425
   ("" (skeep)
    (("" (expand "mpvar")
      (("" (rewrite "multipolylist_monom")
        (("" (rewrite "expt_x1") nil nil)) nil))
      nil))
    nil)
   ((mpvar const-decl "MultiPolyList" multi_polylist nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (multipolylist_monom formula-decl nil multi_polylist nil))
   shostak))
 (multipolylist_varn 0
  (multipolylist_varn-1 nil 3604151480
   ("" (skeep)
    (("" (expand "mpvarn")
      (("" (rewrite "multipolylist_monom") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((mpvarn const-decl "MultiPolyList" multi_polylist nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (multipolylist_monom formula-decl nil multi_polylist nil))
   shostak))
 (multipolylist_sum 0
  (multipolylist_sum-1 nil 3603108095
   ("" (skeep)
    (("" (typepred "mpsum(mpl1,mpl2)")
      (("" (assert)
        (("" (decompose-equality -)
          (("" (inst - "xvar")
            (("" (expand "+") (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}"
     multi_polylist nil)
    (+ const-decl "[T -> real]" real_fun_ops "reals/")
    (meval def-decl "real" multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (multipolylist_prod 0
  (multipolylist_prod-1 nil 3603108126
   ("" (skeep)
    (("" (typepred "mpprod(mpl1,mpl2)") (("" (inst?) nil nil)) nil))
    nil)
   ((mpprod const-decl "{mpl |
         FORALL (xvar):
           meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}"
     multi_polylist nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (meval def-decl "real" multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (multipolylist_scal 0
  (multipolylist_scal-1 nil 3603108154
   ("" (induct "mpl")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("X" "L"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "mpscal" +)
            (("2" (expand "meval" +)
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (mpscal def-decl "MultiPolyList" multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil))
   shostak))
 (multipolylist_pow_TCC1 0
  (multipolylist_pow_TCC1-1 nil 3603099886 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (multipolylist_pow 0
  (multipolylist_pow-1 nil 3603108377
   ("" (induct "n")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skolem 1 "n")
      (("2" (flatten)
        (("2" (assert)
          (("2" (skeep)
            (("2" (expand "mppow" +)
              (("2" (lift-if)
                (("2" (assert)
                  (("2" (ground)
                    (("1" (replaces -1)
                      (("1" (assert)
                        (("1" (expand "^" +)
                          (("1" (expand "expt" +)
                            (("1" (expand "expt" +)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "mpprod(mpl, mppow(mpl, n))")
                      (("2" (rewrite -1)
                        (("2" (hide -1)
                          (("2" (inst?)
                            (("2" (replaces -1)
                              (("2"
                                (expand "^")
                                (("2"
                                  (expand "expt" + 2)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mpprod const-decl "{mpl |
         FORALL (xvar):
           meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}"
     multi_polylist nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (ge_realorder name-judgement "RealOrder" util nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expt def-decl "real" exponentiation nil)
    (monolist_eval const-decl "real" multi_polylist nil)
    (monolist_eval_rec def-decl "{r: real |
         r =
          c *
           product(0, length(ml) - 1,
                   LAMBDA (k: nat):
                     IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
                     ELSE 1
                     ENDIF)}" multi_polylist nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mppow def-decl "MultiPolyList" multi_polylist nil)
    (meval def-decl "real" multi_polylist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (multipolylist_neg 0
  (multipolylist_neg-1 nil 3603108449
   ("" (skeep)
    (("" (expand "mpneg")
      (("" (rewrite "multipolylist_scal") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((mpneg const-decl "MultiPolyList" multi_polylist nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (multipolylist_scal formula-decl nil multi_polylist nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil))
   shostak))
 (multipolylist_minus 0
  (multipolylist_minus-1 nil 3604150775
   ("" (skeep)
    (("" (expand "mpminus")
      (("" (lemma "multipolylist_sum")
        (("" (inst?)
          (("" (replaces -1)
            (("" (lemma "multipolylist_neg")
              (("" (expand "mpneg")
                (("" (inst?) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mpminus const-decl "MultiPolyList" multi_polylist nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (mpscal def-decl "MultiPolyList" multi_polylist nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (multipolylist_neg formula-decl nil multi_polylist nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (mpneg const-decl "MultiPolyList" multi_polylist nil)
    (multipolylist_sum formula-decl nil multi_polylist nil))
   shostak))
 (multipolylist_div 0
  (multipolylist_div-1 nil 3603108470
   ("" (skeep)
    (("" (expand "mpdiv")
      (("" (rewrite "multipolylist_scal") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((mpdiv const-decl "MultiPolyList" multi_polylist nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (multipolylist_scal formula-decl nil multi_polylist nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil))
   shostak))
 (multipolylist_sq 0
  (multipolylist_sq-1 nil 3603108525
   ("" (skeep)
    (("" (rewrite "multipolylist_prod")
      (("" (expand "sq") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((multipolylist_prod formula-decl nil multi_polylist nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (MonoList type-eq-decl nil multi_polylist nil)
    (MultiPolyList type-eq-decl nil multi_polylist nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sq const-decl "nonneg_real" sq "reals/"))
   shostak)))

