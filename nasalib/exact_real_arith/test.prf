(test (new_pi_bnds 0
       (new_pi_bnds-1 nil 3394257208
        ("" (lemma "pi_lemma")
         (("" (expand "cauchy_prop")
           (("" (inst - "210")
             (("" (eval-expr "2^210")
               (("" (eval-expr "cauchy_pi(210)")
                 (("" (flatten) (("" (assert) nil nil)) nil)) nil))
               nil))
             nil))
           nil))
         nil)
        ((pi_bound name-judgement
          "{r: posreal | pi_lb < r AND r < pi_ub}" atan_approx
          "trig_fnd/")
         (posint_exp application-judgement "posint" exponentiation nil)
         (cauchy_prop const-decl "bool" cauchy nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (/= const-decl "boolean" notequal nil)
         (^ const-decl "real" exponentiation nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (int_minus_int_is_int application-judgement "int" integers
          nil)
         (posreal_times_posreal_is_posreal application-judgement
          "posreal" real_types nil)
         (int_plus_int_is_int application-judgement "int" integers nil)
         (posrat_div_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (cauchy_pi const-decl "cauchy_real" atanx nil)
         (cauchy_real nonempty-type-eq-decl nil cauchy nil)
         (cauchy_real? const-decl "bool" cauchy nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (real nonempty-type-from-decl nil reals nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (boolean nonempty-type-decl nil booleans nil)
         (number nonempty-type-decl nil numbers nil)
         (pi_lemma formula-decl nil atanx nil))
        shostak))
      (new_ln2_bnds 0
       (new_ln2_bnds-1 nil 3394261090
        ("" (lemma "cauchy_ln2_lemma")
         (("" (expand "cauchy_prop")
           (("" (inst - "210")
             (("" (eval-expr "2^210")
               (("" (eval-expr "cauchy_ln2(210)")
                 (("" (flatten) (("" (assert) nil nil)) nil)) nil))
               nil))
             nil))
           nil))
         nil)
        ((posint_exp application-judgement "posint" exponentiation nil)
         (cauchy_prop const-decl "bool" cauchy nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (/= const-decl "boolean" notequal nil)
         (^ const-decl "real" exponentiation nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (int_minus_int_is_int application-judgement "int" integers
          nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (int_plus_int_is_int application-judgement "int" integers nil)
         (cauchy_ln2 const-decl "cauchy_posreal" log nil)
         (cauchy_posreal nonempty-type-eq-decl nil cauchy nil)
         (cauchy_posreal? const-decl "bool" cauchy nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (real nonempty-type-from-decl nil reals nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (boolean nonempty-type-decl nil booleans nil)
         (number nonempty-type-decl nil numbers nil)
         (cauchy_ln2_lemma formula-decl nil log nil))
        shostak))
      (new_e_bnds 0
       (new_e_bnds-1 nil 3394258369
        ("" (lemma "exp_lemma" ("x" "1" "cx" "cauchy_int(1)"))
         (("" (rewrite "int_lemma")
           (("" (expand "e")
             (("" (expand "cauchy_prop")
               (("" (inst -1 "210")
                 (("" (eval-expr "2^210")
                   (("" (eval-expr "cauchy_exp(cauchy_int(1))(210)")
                     (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                   nil))
                 nil))
               nil))
             nil))
           nil))
         nil)
        ((int_lemma formula-decl nil int nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (cauchy_prop const-decl "bool" cauchy nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (/= const-decl "boolean" notequal nil)
         (^ const-decl "real" exponentiation nil)
         (cauchy_exp_is_posreal application-judgement "cauchy_posreal"
          exp nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (int_minus_int_is_int application-judgement "int" integers
          nil)
         (posreal_times_posreal_is_posreal application-judgement
          "posreal" real_types nil)
         (int_plus_int_is_int application-judgement "int" integers nil)
         (exp_1 formula-decl nil ln_exp "lnexp_fnd/")
         (cauchy_exp const-decl "[nat -> int]" exp nil)
         (e const-decl "posreal" ln_exp "lnexp_fnd/")
         (exp_lemma formula-decl nil exp nil)
         (number nonempty-type-decl nil numbers nil)
         (boolean nonempty-type-decl nil booleans nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (real nonempty-type-from-decl nil reals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (int nonempty-type-eq-decl nil integers nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (>= const-decl "bool" reals nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (cauchy_real? const-decl "bool" cauchy nil)
         (cauchy_real nonempty-type-eq-decl nil cauchy nil)
         (cauchy_int const-decl "cauchy_real" int nil))
        shostak))
      (new_sqrt2_bnds 0
       (new_sqrt2_bnds-1 nil 3394259998
        ("" (assert)
         (("" (lemma "sqrt_lemma" ("nnx" "2" "nncx" "cauchy_int(2)"))
           (("1" (rewrite "int_lemma")
             (("1" (expand "cauchy_prop")
               (("1" (inst - "210")
                 (("1" (eval-expr "2^210")
                   (("1" (eval-expr "cauchy_sqrt(cauchy_int(2))(210)")
                     (("1" (flatten) (("1" (assert) nil nil)) nil))
                     nil))
                   nil))
                 nil))
               nil))
             nil)
            ("2" (hide 2)
             (("2" (expand "cauchy_nnreal?")
               (("2" (inst + "2") (("2" (rewrite "int_lemma") nil nil))
                 nil))
               nil))
             nil))
           nil))
         nil)
        ((nnreal type-eq-decl nil real_types nil)
         (cauchy_int const-decl "cauchy_real" int nil)
         (cauchy_real nonempty-type-eq-decl nil cauchy nil)
         (cauchy_real? const-decl "bool" cauchy nil)
         (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil)
         (cauchy_nnreal? const-decl "bool" cauchy nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (real nonempty-type-from-decl nil reals nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (boolean nonempty-type-decl nil booleans nil)
         (number nonempty-type-decl nil numbers nil)
         (sqrt_lemma formula-decl nil sqrtx nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (cauchy_prop const-decl "bool" cauchy nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (/= const-decl "boolean" notequal nil)
         (^ const-decl "real" exponentiation nil)
         (int_minus_int_is_int application-judgement "int" integers
          nil)
         (posreal_times_posreal_is_posreal application-judgement
          "posreal" real_types nil)
         (int_plus_int_is_int application-judgement "int" integers nil)
         (cauchy_sqrt const-decl "cauchy_nnreal" sqrtx nil)
         (int_lemma formula-decl nil int nil)
         (sqrt_pos application-judgement "posreal" sqrt "reals/")
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil))
        shostak)))

